{
  "torch.nn.functional.conv1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.functional.conv2d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.functional.conv3d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.functional.conv_transpose1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.conv_transpose2d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.conv_transpose3d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.unfold": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.fold": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.avg_pool1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.avg_pool2d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.avg_pool3d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_pool1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_pool2d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_pool3d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_unpool1d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(output_size, list)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(output_size, list)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "isinstance(output_size, list)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.max_unpool2d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.max_unpool3d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.lp_pool1d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.lp_pool2d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.adaptive_max_pool1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.adaptive_max_pool2d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.adaptive_max_pool3d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "input.ndimension()",
          "op": "==",
          "rhs": "4",
          "expr": "input.ndimension() == 4",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input.ndimension()",
          "op": "==",
          "rhs": "5",
          "expr": "input.ndimension() == 5",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "input.ndimension() == 4",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input.ndimension() == 5",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.adaptive_avg_pool1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.adaptive_avg_pool2d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!input.is_quantized() && output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1",
          "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "2",
          "expr": "output_size.size() == 2",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.suggest_memory_format()",
          "op": "==",
          "rhs": "at::MemoryFormat::ChannelsLast",
          "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_mkldnn()",
          "op": "",
          "rhs": "",
          "expr": "input.is_mkldnn()",
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0",
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size.size() == 2",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input.is_mkldnn()",
        "src": "cpp",
        "type": "boolean"
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0",
        "src": "cpp",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.adaptive_avg_pool3d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "input.suggest_memory_format()",
          "op": "==",
          "rhs": "at::MemoryFormat::ChannelsLast3d",
          "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast3d",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0 && output_size[2] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1 && output_size[2] == 1",
          "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "3",
          "expr": "output_size.size() == 3",
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast3d",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size.size() == 3",
        "src": "cpp",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.threshold": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.threshold_": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.relu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.relu_": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardtanh": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "min_val",
          "op": ">",
          "rhs": "max_val",
          "expr": "min_val > max_val",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "min_val > max_val",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.hardtanh_": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardswish": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.relu6": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.elu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.elu_": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.selu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.celu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "alpha.to",
          "op": "<",
          "rhs": "double>() != 0",
          "expr": "alpha.to<double>() != 0",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "alpha.to<double>() != 0",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.leaky_relu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.leaky_relu_": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.prelu": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.rrelu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.rrelu_": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.glu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "input.dim() == 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.dim() == 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.gelu": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.logsigmoid": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardshrink": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.tanhshrink": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.softsign": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.softplus": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.softmin": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.softmax": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.softshrink": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.gumbel_softmax": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(logits)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(logits)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "eps",
          "op": "!=",
          "rhs": "1e-10",
          "expr": "eps != 1e-10",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "hard",
          "op": "",
          "rhs": "",
          "expr": "hard",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(logits)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "eps != 1e-10",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "hard",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.log_softmax": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.tanh": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.sigmoid": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardsigmoid": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.silu": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.batch_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "training",
          "op": "",
          "rhs": "",
          "expr": "training",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "training",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.instance_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "use_input_stats",
          "op": "",
          "rhs": "",
          "expr": "use_input_stats",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "use_input_stats",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.layer_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, weight, bias)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, weight, bias)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.local_response_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "input.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "input.numel() == 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "input.numel() == 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.normalize": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, out)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, out)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, out)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.functional.linear": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "bias->defined()",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_mkldnn()",
          "op": "",
          "rhs": "",
          "expr": "input.is_mkldnn()",
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "bias->defined() && !input.is_xla()",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input_dim",
          "op": "==",
          "rhs": "3",
          "expr": "input.is_contiguous() && input_dim == 3",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "input_dim == 2 && bias->defined()",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "bias->defined()",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input.is_mkldnn()",
        "src": "cpp",
        "type": "boolean"
      },
      {
        "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input.is_contiguous() && input_dim == 3",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.bilinear": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.dropout": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.alpha_dropout": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.feature_alpha_dropout": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.dropout2d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.dropout3d": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.embedding": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "padding_idx",
          "op": "<",
          "rhs": "0",
          "expr": "padding_idx < 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": ">",
          "rhs": "0",
          "expr": "padding_idx > 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": "is",
          "rhs": "not None",
          "expr": "padding_idx is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": "<",
          "rhs": "weight.size(0)",
          "expr": "padding_idx < weight.size(0)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": ">=",
          "rhs": "-weight.size(0)",
          "expr": "padding_idx >= -weight.size(0)",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "weight.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "weight.dim() == 2",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "padding_idx < 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "padding_idx > 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "padding_idx is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "has_torch_function_variadic(input, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "padding_idx < weight.size(0)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "padding_idx >= -weight.size(0)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "weight.dim() == 2",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.embedding_bag": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "per_sample_weights",
          "op": "is",
          "rhs": "not None",
          "expr": "per_sample_weights is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "sparse",
          "op": "",
          "rhs": "",
          "expr": "sparse",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "per_sample_weights",
          "op": "is",
          "rhs": "not None and mode != 'sum'",
          "expr": "per_sample_weights is not None and mode != 'sum'",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "1",
          "expr": "input.dim() == 1",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'max'",
          "expr": "mode == 'max'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'mean'",
          "expr": "mode == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "scale_grad_by_freq",
          "op": "",
          "rhs": "",
          "expr": "scale_grad_by_freq",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "offsets",
          "op": "is",
          "rhs": "not None",
          "expr": "offsets is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "offsets.dim()",
          "op": "!=",
          "rhs": "1",
          "expr": "offsets.dim() != 1",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "weight.dtype",
          "op": "==",
          "rhs": "torch.long and input.is_floating_point()",
          "expr": "weight.dtype == torch.long and input.is_floating_point()",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not weight.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "not weight.dim() == 2",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "offsets",
          "op": "is",
          "rhs": "None",
          "expr": "offsets is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'sum'",
          "expr": "mode == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "per_sample_weights",
          "op": "is",
          "rhs": "not None and input.size() != per_sample_weights.size()",
          "expr": "per_sample_weights is not None and input.size() != per_sample_weights.size()",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "input.dim() == 2",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "per_sample_weights is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "sparse",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "per_sample_weights is not None and mode != 'sum'",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.dim() == 1",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode == 'max'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "scale_grad_by_freq",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "offsets is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "offsets.dim() != 1",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "weight.dtype == torch.long and input.is_floating_point()",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "not weight.dim() == 2",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "offsets is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "mode == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "per_sample_weights is not None and input.size() != per_sample_weights.size()",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 2",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.functional.one_hot": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pairwise_distance": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.cosine_similarity": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pdist": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.binary_cross_entropy": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "target.size()",
          "op": "!=",
          "rhs": "input.size()",
          "expr": "target.size() != input.size()",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "target.size() != input.size()",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.binary_cross_entropy_with_logits": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "pos_weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "pos_weight.defined()",
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "weight.defined()",
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "pos_weight.defined()",
        "src": "cpp",
        "type": "boolean"
      },
      {
        "expr": "weight.defined()",
        "src": "cpp",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.poisson_nll_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "'none' and reduction != 'mean' and (reduction != 'sum')",
          "expr": "reduction != 'none' and reduction != 'mean' and (reduction != 'sum')",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction != 'none' and reduction != 'mean' and (reduction != 'sum')",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.cosine_embedding_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input1, input2, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input1, input2, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input1, input2, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.cross_entropy": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.ctc_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.functional.hinge_embedding_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.kl_div": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean'",
          "expr": "reduction == 'batchmean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean' and input.dim() != 0",
          "expr": "reduction == 'batchmean' and input.dim() != 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "reduction == 'batchmean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'batchmean' and input.dim() != 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.l1_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.mse_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check"
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.margin_ranking_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input1, input2, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input1, input2, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "input1.dim()",
          "op": "!=",
          "rhs": "input2.dim() or input1.dim() != target.dim()",
          "expr": "input1.dim() != input2.dim() or input1.dim() != target.dim()",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input1, input2, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "input1.dim() != input2.dim() or input1.dim() != target.dim()",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.multilabel_margin_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.multilabel_soft_margin_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'none'",
          "expr": "reduction == 'none'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction == 'none'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.functional.multi_margin_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight.dim()",
          "op": "!=",
          "rhs": "1",
          "expr": "weight.dim() != 1",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "!=",
          "rhs": "1 and p != 2",
          "expr": "p != 1 and p != 2",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "weight.dim() != 1",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "p != 1 and p != 2",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.functional.nll_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.smooth_l1_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "beta",
          "op": "==",
          "rhs": "0.0",
          "expr": "beta == 0.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "beta == 0.0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check"
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.soft_margin_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.functional.triplet_margin_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(anchor, positive, negative)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "margin",
          "op": "<=",
          "rhs": "0",
          "expr": "margin <= 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "margin <= 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.triplet_margin_with_distance_loss": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "distance_function",
          "op": "is",
          "rhs": "None",
          "expr": "distance_function is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "swap",
          "op": "",
          "rhs": "",
          "expr": "swap",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(anchor, positive, negative)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "not in",
          "rhs": "('mean', 'sum', 'none')",
          "expr": "reduction not in ('mean', 'sum', 'none')",
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "margin",
          "op": "<=",
          "rhs": "0",
          "expr": "margin <= 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "distance_function is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "swap",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction not in ('mean', 'sum', 'none')",
        "src": "python",
        "type": "membership_check"
      },
      {
        "expr": "margin <= 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.pixel_shuffle": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pixel_unshuffle": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pad": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "torch.are_deterministic_algorithms_enabled() and (input.is_cuda or input.is_xpu)",
          "op": "",
          "rhs": "",
          "expr": "torch.are_deterministic_algorithms_enabled() and (input.is_cuda or input.is_xpu)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'replicate'",
          "expr": "mode == 'replicate'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "torch.are_deterministic_algorithms_enabled() and (input.is_cuda or input.is_xpu)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "mode == 'replicate'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.interpolate": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'nearest'",
          "expr": "input.dim() == 3 and mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'nearest-exact'",
          "expr": "input.dim() == 4 and mode == 'nearest-exact'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "torch.are_deterministic_algorithms_enabled() and (input.is_cuda or input.is_xpu)",
          "op": "",
          "rhs": "",
          "expr": "torch.are_deterministic_algorithms_enabled() and (input.is_cuda or input.is_xpu)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'bicubic'",
          "expr": "input.dim() == 4 and mode == 'bicubic'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'area'",
          "expr": "input.dim() == 4 and mode == 'area'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'linear'",
          "expr": "input.dim() == 3 and mode == 'linear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'area'",
          "expr": "input.dim() == 5 and mode == 'area'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'nearest'",
          "expr": "input.dim() == 5 and mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'bilinear'",
          "expr": "input.dim() == 3 and mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'linear'",
          "expr": "input.dim() == 5 and mode == 'linear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None and recompute_scale_factor and (size is not None)",
          "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'area' and output_size is None",
          "expr": "mode == 'area' and output_size is None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "not None",
          "expr": "align_corners is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "None",
          "expr": "scale_factor is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'trilinear'",
          "expr": "input.dim() == 3 and mode == 'trilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'bilinear'",
          "expr": "input.dim() == 5 and mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'linear'",
          "expr": "input.dim() == 4 and mode == 'linear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'nearest'",
          "expr": "input.dim() == 4 and mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "antialias",
          "op": "",
          "rhs": "",
          "expr": "antialias",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'nearest-exact'",
          "expr": "input.dim() == 5 and mode == 'nearest-exact'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'bilinear'",
          "expr": "input.dim() == 4 and mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'trilinear'",
          "expr": "input.dim() == 4 and mode == 'trilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "in",
          "rhs": "('nearest', 'area', 'nearest-exact')",
          "expr": "mode in ('nearest', 'area', 'nearest-exact')",
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None and recompute_scale_factor",
          "expr": "recompute_scale_factor is not None and recompute_scale_factor",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'nearest-exact'",
          "expr": "input.dim() == 3 and mode == 'nearest-exact'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "None",
          "expr": "size is None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'trilinear'",
          "expr": "input.dim() == 5 and mode == 'trilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'area'",
          "expr": "input.dim() == 3 and mode == 'area'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None and scale_factor is not None",
          "expr": "size is not None and scale_factor is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "antialias and (not (mode",
          "op": "in",
          "rhs": "('bilinear', 'bicubic') and input.ndim == 4))",
          "expr": "antialias and (not (mode in ('bilinear', 'bicubic') and input.ndim == 4))",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'nearest-exact'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "torch.are_deterministic_algorithms_enabled() and (input.is_cuda or input.is_xpu)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "input.dim() == 4 and mode == 'bicubic'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'area'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'linear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'area'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'linear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "mode == 'area' and output_size is None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "align_corners is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "scale_factor is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'trilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'linear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "antialias",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "input.dim() == 5 and mode == 'nearest-exact'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'trilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode in ('nearest', 'area', 'nearest-exact')",
        "src": "python",
        "type": "membership_check"
      },
      {
        "expr": "recompute_scale_factor is not None and recompute_scale_factor",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'nearest-exact'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size is None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'trilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'area'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size is not None and scale_factor is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "antialias and (not (mode in ('bilinear', 'bicubic') and input.ndim == 4))",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.upsample": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.upsample_nearest": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.upsample_bilinear": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.grid_sample": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "!=",
          "rhs": "'bilinear' and mode != 'nearest' and (mode != 'bicubic')",
          "expr": "mode != 'bilinear' and mode != 'nearest' and (mode != 'bicubic')",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "padding_mode",
          "op": "==",
          "rhs": "'zeros'",
          "expr": "padding_mode == 'zeros'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, grid)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, grid)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "padding_mode",
          "op": "==",
          "rhs": "'border'",
          "expr": "padding_mode == 'border'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'nearest'",
          "expr": "mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "padding_mode",
          "op": "!=",
          "rhs": "'zeros' and padding_mode != 'border' and (padding_mode != 'reflection')",
          "expr": "padding_mode != 'zeros' and padding_mode != 'border' and (padding_mode != 'reflection')",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'bilinear'",
          "expr": "mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "mode != 'bilinear' and mode != 'nearest' and (mode != 'bicubic')",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "padding_mode == 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "has_torch_function_variadic(input, grid)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "padding_mode == 'border'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "padding_mode != 'zeros' and padding_mode != 'border' and (padding_mode != 'reflection')",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.functional.affine_grid": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(theta)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(theta)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "==",
          "rhs": "4",
          "expr": "len(size) == 4",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "align_corners and min(spatial_size)",
          "op": "==",
          "rhs": "1",
          "expr": "align_corners and min(spatial_size) == 1",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "theta.dim()",
          "op": "!=",
          "rhs": "3 or theta.shape[-2] != 3 or theta.shape[-1] != 4",
          "expr": "theta.dim() != 3 or theta.shape[-2] != 3 or theta.shape[-1] != 4",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "min(size)",
          "op": "<=",
          "rhs": "0",
          "expr": "min(size) <= 0",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "theta.dim()",
          "op": "!=",
          "rhs": "3 or theta.shape[-2] != 2 or theta.shape[-1] != 3",
          "expr": "theta.dim() != 3 or theta.shape[-2] != 2 or theta.shape[-1] != 3",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not theta.is_floating_point()",
          "op": "",
          "rhs": "",
          "expr": "not theta.is_floating_point()",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "==",
          "rhs": "5",
          "expr": "len(size) == 5",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(theta)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "len(size) == 4",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "align_corners and min(spatial_size) == 1",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "theta.dim() != 3 or theta.shape[-2] != 3 or theta.shape[-1] != 4",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "min(size) <= 0",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "theta.dim() != 3 or theta.shape[-2] != 2 or theta.shape[-1] != 3",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "not theta.is_floating_point()",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "len(size) == 5",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.is_tensor": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.is_storage": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_default_dtype": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_default_tensor_type": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(t, str)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(t, str)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(t, str)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.set_printoptions": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "profile",
          "op": "==",
          "rhs": "'short'",
          "expr": "profile == 'short'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "profile",
          "op": "is",
          "rhs": "not None",
          "expr": "profile is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "threshold",
          "op": "is",
          "rhs": "not None",
          "expr": "threshold is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "profile",
          "op": "==",
          "rhs": "'default'",
          "expr": "profile == 'default'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "edgeitems",
          "op": "is",
          "rhs": "not None",
          "expr": "edgeitems is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "precision",
          "op": "is",
          "rhs": "not None",
          "expr": "precision is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "profile",
          "op": "==",
          "rhs": "'full'",
          "expr": "profile == 'full'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "linewidth",
          "op": "is",
          "rhs": "not None",
          "expr": "linewidth is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "profile == 'short'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "profile is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "threshold is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "profile == 'default'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "edgeitems is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "precision is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "profile == 'full'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "linewidth is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.randn": {
    "type": "factory",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.empty": {
    "type": "factory",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "options.layout()",
          "op": "==",
          "rhs": "Layout::Strided",
          "expr": "options.layout() == Layout::Strided",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
          "op": "",
          "rhs": "",
          "expr": "options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
          "type": "device_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "options.layout() == Layout::Strided",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
        "src": "cpp",
        "type": "device_check"
      }
    ]
  },
  "torch.zeros": {
    "type": "factory",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ones": {
    "type": "factory",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arange": {
    "type": "factory",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.full": {
    "type": "factory",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "options.layout()",
          "op": "!=",
          "rhs": "kSparse",
          "expr": "options.layout() != kSparse",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "options.layout() != kSparse",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.split": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(tensor)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(tensor)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "self.dim() > 0",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(tensor)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.dim() > 0",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.Generator": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.seed": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not torch.xpu._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "not torch.xpu._is_in_bad_fork()",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not torch.cuda._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "not torch.cuda._is_in_bad_fork()",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not torch.mps._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "not torch.mps._is_in_bad_fork()",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not torch.xpu._is_in_bad_fork()",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not torch.cuda._is_in_bad_fork()",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not torch.mps._is_in_bad_fork()",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.manual_seed": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.initial_seed": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.get_rng_state": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_rng_state": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.quasirandom.SobolEngine": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.save": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "_use_new_zipfile_serialization",
          "op": "",
          "rhs": "",
          "expr": "_use_new_zipfile_serialization",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "_use_new_zipfile_serialization",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.load": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "mmap",
          "op": "",
          "rhs": "",
          "expr": "mmap",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "mmap",
          "op": "is",
          "rhs": "None",
          "expr": "mmap is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "'encoding'",
          "op": "not in",
          "rhs": "pickle_load_args.keys()",
          "expr": "'encoding' not in pickle_load_args.keys()",
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "not _is_path(f)",
          "op": "",
          "rhs": "",
          "expr": "not _is_path(f)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "pickle_module",
          "op": "is",
          "rhs": "None",
          "expr": "pickle_module is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "weights_only",
          "op": "is",
          "rhs": "None",
          "expr": "weights_only is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "weights_only",
          "op": "",
          "rhs": "",
          "expr": "weights_only",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "pickle_module",
          "op": "is",
          "rhs": "not None",
          "expr": "pickle_module is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "mmap",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "mmap is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "'encoding' not in pickle_load_args.keys()",
        "src": "python",
        "type": "membership_check"
      },
      {
        "expr": "not _is_path(f)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "pickle_module is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "weights_only is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "weights_only",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "pickle_module is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.set_grad_enabled": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "p",
          "op": "==",
          "rhs": "'nuc'",
          "expr": "p == 'nuc'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None and out is None and (dtype is None) and (p is not None)",
          "expr": "dim is None and out is None and (dtype is None) and (p is not None)",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "not None",
          "expr": "dtype is not None",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(p, str)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(p, str)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "not None",
          "expr": "dim is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.layout",
          "op": "==",
          "rhs": "torch.strided and input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
          "expr": "input.layout == torch.strided and input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "==",
          "rhs": "'fro' and (dim is None or isinstance(dim, (int, torch.SymInt)) or len(dim) <= 2)",
          "expr": "p == 'fro' and (dim is None or isinstance(dim, (int, torch.SymInt)) or len(dim) <= 2)",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(dim, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dim, (int, torch.SymInt))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "==",
          "rhs": "'fro'",
          "expr": "p == 'fro'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(p, str)",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(p, str)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "p == 'nuc'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "dim is None and out is None and (dtype is None) and (p is not None)",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "dtype is not None",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "isinstance(p, str)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "dim is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.layout == torch.strided and input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
        "src": "python",
        "type": "device_check"
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "p == 'fro' and (dim is None or isinstance(dim, (int, torch.SymInt)) or len(dim) <= 2)",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "isinstance(dim, (int, torch.SymInt))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "p == 'fro'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "not isinstance(p, str)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.unique": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.unique_consecutive": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!dim.has_value() || (dim.value()",
          "op": "==",
          "rhs": "0 && self.dim() == 1)",
          "expr": "!dim.has_value() || (dim.value() == 0 && self.dim() == 1)",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!dim.has_value() || (dim.value() == 0 && self.dim() == 1)",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.stft": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "center",
          "op": "",
          "rhs": "",
          "expr": "center",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "center",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.atleast_1d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atleast_2d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atleast_3d": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.block_diag": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.broadcast_tensors": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.broadcast_shapes": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cartesian_prod": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cdist": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "compute_mode",
          "op": "==",
          "rhs": "'use_mm_for_euclid_dist'",
          "expr": "compute_mode == 'use_mm_for_euclid_dist'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "compute_mode",
          "op": "==",
          "rhs": "'use_mm_for_euclid_dist_if_necessary'",
          "expr": "compute_mode == 'use_mm_for_euclid_dist_if_necessary'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "compute_mode",
          "op": "==",
          "rhs": "'donot_use_mm_for_euclid_dist'",
          "expr": "compute_mode == 'donot_use_mm_for_euclid_dist'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(x1, x2)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(x1, x2)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "compute_mode == 'use_mm_for_euclid_dist'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "compute_mode == 'use_mm_for_euclid_dist_if_necessary'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "compute_mode == 'donot_use_mm_for_euclid_dist'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "has_torch_function_variadic(x1, x2)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.einsum": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function(operands)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function(operands)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(operands)",
          "op": "==",
          "rhs": "1 and isinstance(operands[0], (list, tuple))",
          "expr": "len(operands) == 1 and isinstance(operands[0], (list, tuple))",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "len(operands)",
          "op": "<=",
          "rhs": "2 or not opt_einsum.enabled",
          "expr": "len(operands) <= 2 or not opt_einsum.enabled",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function(operands)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "len(operands) == 1 and isinstance(operands[0], (list, tuple))",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "len(operands) <= 2 or not opt_einsum.enabled",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.meshgrid": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tensordot": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "dims",
          "op": "<",
          "rhs": "0",
          "expr": "dims < 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "dims.size()[0]",
          "op": "==",
          "rhs": "2",
          "expr": "dims.size()[0] == 2",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(dims, (tuple, list))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dims, (tuple, list))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "dims",
          "op": ">",
          "rhs": "min(a.dim(), b.dim())",
          "expr": "dims > min(a.dim(), b.dim())",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(dims, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dims, torch.Tensor)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(a, b)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(a, b)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "isinstance(dims, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dims, (int, torch.SymInt))",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "dims < 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "dims.size()[0] == 2",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "isinstance(dims, (tuple, list))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "dims > min(a.dim(), b.dim())",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(dims, torch.Tensor)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "has_torch_function_variadic(a, b)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "isinstance(dims, (int, torch.SymInt))",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.chain_matmul": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function(matrices)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function(matrices)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function(matrices)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.lu": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.svd_lowrank": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.pca_lowrank": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "len(A.shape)",
          "op": "!=",
          "rhs": "2",
          "expr": "len(A.shape) != 2",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "type(A)",
          "op": "is",
          "rhs": "not torch.Tensor and has_torch_function((A,))",
          "expr": "type(A) is not torch.Tensor and has_torch_function((A,))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "q",
          "op": "is",
          "rhs": "None",
          "expr": "q is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "not niter",
          "op": ">=",
          "rhs": "0",
          "expr": "not niter >= 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "not center",
          "op": "",
          "rhs": "",
          "expr": "not center",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "_utils.is_sparse(A)",
          "op": "",
          "rhs": "",
          "expr": "_utils.is_sparse(A)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not (q",
          "op": ">=",
          "rhs": "0 and q <= min(m, n))",
          "expr": "not (q >= 0 and q <= min(m, n))",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "len(A.shape) != 2",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "type(A) is not torch.Tensor and has_torch_function((A,))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "q is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "not niter >= 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "not center",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "_utils.is_sparse(A)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not (q >= 0 and q <= min(m, n))",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.lobpcg": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "A.requires_grad or (B",
          "op": "is",
          "rhs": "not None and B.requires_grad)",
          "expr": "A.requires_grad or (B is not None and B.requires_grad)",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "A.requires_grad or (B is not None and B.requires_grad)",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.compiled_with_cxx11_abi": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.use_deterministic_algorithms": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.are_deterministic_algorithms_enabled": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch._assert": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "condition",
          "op": "",
          "rhs": "",
          "expr": "condition",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "type(condition)",
          "op": "is",
          "rhs": "not torch.Tensor and overrides.has_torch_function((condition,))",
          "expr": "type(condition) is not torch.Tensor and overrides.has_torch_function((condition,))",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "condition",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "type(condition) is not torch.Tensor and overrides.has_torch_function((condition,))",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Sequential": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ModuleList": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ModuleDict": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ParameterList": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ParameterDict": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.modules.module.register_module_forward_pre_hook": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.modules.module.register_module_forward_hook": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "always_call",
          "op": "",
          "rhs": "",
          "expr": "always_call",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "always_call",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.modules.module.register_module_backward_hook": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Conv1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.Conv2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.Conv3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.ConvTranspose1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.ConvTranspose2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.ConvTranspose3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.LazyConv1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.LazyConv2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.LazyConv3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.LazyConvTranspose1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.LazyConvTranspose2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.LazyConvTranspose3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.Unfold": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Fold": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxPool1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxPool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxPool3d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxUnpool1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.MaxUnpool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.MaxUnpool3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.AvgPool1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AvgPool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AvgPool3d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.FractionalMaxPool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.LPPool1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.LPPool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.AdaptiveMaxPool1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveMaxPool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveMaxPool3d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveAvgPool1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveAvgPool2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!input.is_quantized() && output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1",
          "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "2",
          "expr": "output_size.size() == 2",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0",
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size.size() == 2",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0",
        "src": "cpp",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.AdaptiveAvgPool3d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0 && output_size[2] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1 && output_size[2] == 1",
          "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "3",
          "expr": "output_size.size() == 3",
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
        "src": "cpp",
        "type": "shape_check"
      },
      {
        "expr": "output_size.size() == 3",
        "src": "cpp",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.ReflectionPad1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReflectionPad2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReplicationPad1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReplicationPad2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReplicationPad3d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ZeroPad2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ConstantPad1d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ConstantPad2d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ConstantPad3d": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ELU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Hardshrink": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Hardsigmoid": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Hardtanh": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "min_val",
          "op": ">",
          "rhs": "max_val",
          "expr": "min_val > max_val",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "min_val > max_val",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Hardswish": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.LeakyReLU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.MultiheadAttention": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "query.dtype",
          "op": "!=",
          "rhs": "self.in_proj_weight.dtype",
          "expr": "query.dtype != self.in_proj_weight.dtype",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "add_zero_attn",
          "op": "",
          "rhs": "",
          "expr": "add_zero_attn",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.in_proj_bias",
          "op": "is",
          "rhs": "not None and query.dtype != self.in_proj_bias.dtype",
          "expr": "self.in_proj_bias is not None and query.dtype != self.in_proj_bias.dtype",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not self.batch_first",
          "op": "",
          "rhs": "",
          "expr": "not self.batch_first",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.num_heads % 2",
          "op": "!=",
          "rhs": "0",
          "expr": "self.num_heads % 2 != 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "self.batch_first and is_batched",
          "op": "",
          "rhs": "",
          "expr": "self.batch_first and is_batched",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "isinstance(embed_dim, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(embed_dim, torch.Tensor)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.add_zero_attn",
          "op": "",
          "rhs": "",
          "expr": "self.add_zero_attn",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "query.is_nested() || query.sizes()[2]",
          "op": "==",
          "rhs": "embed_dim",
          "expr": "query.is_nested() || query.sizes()[2] == embed_dim",
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "query.dtype != self.in_proj_weight.dtype",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "add_zero_attn",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.in_proj_bias is not None and query.dtype != self.in_proj_bias.dtype",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "not self.batch_first",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.num_heads % 2 != 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "self.batch_first and is_batched",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "isinstance(embed_dim, torch.Tensor)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.add_zero_attn",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "query.is_nested() || query.sizes()[2] == embed_dim",
        "src": "cpp",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.PReLU": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReLU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.ReLU6": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.RReLU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.SELU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.CELU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "alpha.to",
          "op": "<",
          "rhs": "double>() != 0",
          "expr": "alpha.to<double>() != 0",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "alpha.to<double>() != 0",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.SiLU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Softplus": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Softshrink": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Threshold": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Softmin": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.Softmax": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.LogSoftmax": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.AdaptiveLogSoftmaxWithLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.BatchNorm1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training and self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training and self.track_running_stats",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training and self.track_running_stats",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.BatchNorm2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training and self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training and self.track_running_stats",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training and self.track_running_stats",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.BatchNorm3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training and self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training and self.track_running_stats",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training and self.track_running_stats",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.GroupNorm": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.SyncBatchNorm": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.process_group",
          "op": "",
          "rhs": "",
          "expr": "self.process_group",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.training and self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training and self.track_running_stats",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.device.type",
          "op": "not in",
          "rhs": "['cuda', torch._C._get_privateuse1_backend_name()]",
          "expr": "input.device.type not in ['cuda', torch._C._get_privateuse1_backend_name()]",
          "type": "device_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.process_group",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.training and self.track_running_stats",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.device.type not in ['cuda', torch._C._get_privateuse1_backend_name()]",
        "src": "python",
        "type": "device_check"
      }
    ]
  },
  "torch.nn.InstanceNorm1d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.size(feature_dim)",
          "op": "!=",
          "rhs": "self.num_features",
          "expr": "input.size(feature_dim) != self.num_features",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.affine",
          "op": "",
          "rhs": "",
          "expr": "self.affine",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.size(feature_dim) != self.num_features",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "self.affine",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.InstanceNorm2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.size(feature_dim)",
          "op": "!=",
          "rhs": "self.num_features",
          "expr": "input.size(feature_dim) != self.num_features",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.affine",
          "op": "",
          "rhs": "",
          "expr": "self.affine",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.size(feature_dim) != self.num_features",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "self.affine",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.InstanceNorm3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.size(feature_dim)",
          "op": "!=",
          "rhs": "self.num_features",
          "expr": "input.size(feature_dim) != self.num_features",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.affine",
          "op": "",
          "rhs": "",
          "expr": "self.affine",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.size(feature_dim) != self.num_features",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "self.affine",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.LayerNorm": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.LocalResponseNorm": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.RNNBase": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.RNN": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.dtype",
          "op": "!=",
          "rhs": "self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
          "expr": "input.dtype != self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.input_size",
          "op": "!=",
          "rhs": "input.size(-1)",
          "expr": "self.input_size != input.size(-1)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(fw, Tensor) or not fw.dtype",
          "op": "==",
          "rhs": "dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
          "expr": "not isinstance(fw, Tensor) or not fw.dtype == dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.dtype != self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "self.input_size != input.size(-1)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "not isinstance(fw, Tensor) or not fw.dtype == dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
        "src": "python",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.LSTM": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.dtype",
          "op": "!=",
          "rhs": "self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
          "expr": "input.dtype != self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.input_size",
          "op": "!=",
          "rhs": "input.size(-1)",
          "expr": "self.input_size != input.size(-1)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.proj_size",
          "op": ">",
          "rhs": "0",
          "expr": "self.proj_size > 0",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(fw, Tensor) or not fw.dtype",
          "op": "==",
          "rhs": "dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
          "expr": "not isinstance(fw, Tensor) or not fw.dtype == dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.dtype != self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "self.input_size != input.size(-1)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "self.proj_size > 0",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "not isinstance(fw, Tensor) or not fw.dtype == dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
        "src": "python",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.GRU": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.dtype",
          "op": "!=",
          "rhs": "self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
          "expr": "input.dtype != self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.input_size",
          "op": "!=",
          "rhs": "input.size(-1)",
          "expr": "self.input_size != input.size(-1)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(fw, Tensor) or not fw.dtype",
          "op": "==",
          "rhs": "dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
          "expr": "not isinstance(fw, Tensor) or not fw.dtype == dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.dtype != self._flat_weights[0].dtype and (not torch._C._is_any_autocast_enabled())",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "self.input_size != input.size(-1)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "not isinstance(fw, Tensor) or not fw.dtype == dtype or (not fw.is_cuda) or (not torch.backends.cudnn.is_acceptable(fw))",
        "src": "python",
        "type": "dtype_check"
      }
    ]
  },
  "torch.nn.RNNCell": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.nonlinearity",
          "op": "==",
          "rhs": "'tanh'",
          "expr": "self.nonlinearity == 'tanh'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "self.nonlinearity",
          "op": "==",
          "rhs": "'relu'",
          "expr": "self.nonlinearity == 'relu'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.nonlinearity == 'tanh'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "self.nonlinearity == 'relu'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.LSTMCell": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.GRUCell": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Transformer": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not self.batch_first and src.size(1)",
          "op": "!=",
          "rhs": "tgt.size(1) and is_batched",
          "expr": "not self.batch_first and src.size(1) != tgt.size(1) and is_batched",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "src.size(-1)",
          "op": "!=",
          "rhs": "self.d_model or tgt.size(-1) != self.d_model",
          "expr": "src.size(-1) != self.d_model or tgt.size(-1) != self.d_model",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.batch_first and src.size(0)",
          "op": "!=",
          "rhs": "tgt.size(0) and is_batched",
          "expr": "self.batch_first and src.size(0) != tgt.size(0) and is_batched",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not self.batch_first and src.size(1) != tgt.size(1) and is_batched",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "src.size(-1) != self.d_model or tgt.size(-1) != self.d_model",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "self.batch_first and src.size(0) != tgt.size(0) and is_batched",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.TransformerEncoder": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.norm",
          "op": "is",
          "rhs": "not None",
          "expr": "self.norm is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.norm is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.TransformerDecoder": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.norm",
          "op": "is",
          "rhs": "not None",
          "expr": "self.norm is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.norm is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.TransformerEncoderLayer": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not self.self_attn.batch_first",
          "op": "",
          "rhs": "",
          "expr": "not self.self_attn.batch_first",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.norm_first",
          "op": "",
          "rhs": "",
          "expr": "self.norm_first",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "norm_first",
          "op": "",
          "rhs": "",
          "expr": "norm_first",
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "!norm_first",
          "op": "",
          "rhs": "",
          "expr": "!norm_first",
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "not self.self_attn.batch_first",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.norm_first",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "norm_first",
        "src": "cpp",
        "type": "boolean"
      },
      {
        "expr": "!norm_first",
        "src": "cpp",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.TransformerDecoderLayer": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.norm_first",
          "op": "",
          "rhs": "",
          "expr": "self.norm_first",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.norm_first",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.Identity": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Linear": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "bias->defined()",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "bias->defined() && !input.is_xla()",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "input_dim == 2 && bias->defined()",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "bias->defined()",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.Bilinear": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.LazyLinear": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "bias->defined()",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "bias->defined() && !input.is_xla()",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "input_dim == 2 && bias->defined()",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "bias->defined()",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.Dropout": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.Dropout2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.Dropout3d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.AlphaDropout": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 or p > 1.0",
          "expr": "p < 0.0 or p > 1.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "p < 0.0 or p > 1.0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.Embedding": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "padding_idx",
          "op": "<",
          "rhs": "0",
          "expr": "padding_idx < 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": ">",
          "rhs": "0",
          "expr": "padding_idx > 0",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": "is",
          "rhs": "not None",
          "expr": "padding_idx is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "padding_idx < 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "padding_idx > 0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "padding_idx is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.EmbeddingBag": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "sparse",
          "op": "",
          "rhs": "",
          "expr": "sparse",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "per_sample_weights",
          "op": "is",
          "rhs": "not None and mode != 'sum'",
          "expr": "per_sample_weights is not None and mode != 'sum'",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'max'",
          "expr": "mode == 'max'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'mean'",
          "expr": "mode == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "scale_grad_by_freq",
          "op": "",
          "rhs": "",
          "expr": "scale_grad_by_freq",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight.dtype",
          "op": "==",
          "rhs": "torch.long and input.is_floating_point()",
          "expr": "weight.dtype == torch.long and input.is_floating_point()",
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'sum'",
          "expr": "mode == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "sparse",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "per_sample_weights is not None and mode != 'sum'",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "mode == 'max'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "scale_grad_by_freq",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "weight.dtype == torch.long and input.is_floating_point()",
        "src": "python",
        "type": "dtype_check"
      },
      {
        "expr": "mode == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.CosineSimilarity": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.PairwiseDistance": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.L1Loss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.MSELoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check"
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.CrossEntropyLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.NLLLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.CTCLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.PoissonNLLLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "'none' and reduction != 'mean' and (reduction != 'sum')",
          "expr": "reduction != 'none' and reduction != 'mean' and (reduction != 'sum')",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction != 'none' and reduction != 'mean' and (reduction != 'sum')",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.GaussianNLLLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "full",
          "op": "",
          "rhs": "",
          "expr": "full",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "'none' and reduction != 'mean' and (reduction != 'sum')",
          "expr": "reduction != 'none' and reduction != 'mean' and (reduction != 'sum')",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "full",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "reduction != 'none' and reduction != 'mean' and (reduction != 'sum')",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.KLDivLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean'",
          "expr": "reduction == 'batchmean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean' and input.dim() != 0",
          "expr": "reduction == 'batchmean' and input.dim() != 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction == 'batchmean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'batchmean' and input.dim() != 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.BCELoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.BCEWithLogitsLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "pos_weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "pos_weight.defined()",
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "weight.defined()",
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "pos_weight.defined()",
        "src": "cpp",
        "type": "boolean"
      },
      {
        "expr": "weight.defined()",
        "src": "cpp",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.MarginRankingLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.HingeEmbeddingLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.MultiLabelMarginLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.SmoothL1Loss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "beta",
          "op": "==",
          "rhs": "0.0",
          "expr": "beta == 0.0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "beta == 0.0",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check"
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.SoftMarginLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.MultiLabelSoftMarginLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'none'",
          "expr": "reduction == 'none'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "reduction == 'none'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.CosineEmbeddingLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.MultiMarginLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight.dim()",
          "op": "!=",
          "rhs": "1",
          "expr": "weight.dim() != 1",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "!=",
          "rhs": "1 and p != 2",
          "expr": "p != 1 and p != 2",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "weight.dim() != 1",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "p != 1 and p != 2",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.TripletMarginLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None or reduce is not None",
          "expr": "size_average is not None or reduce is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "margin",
          "op": "<=",
          "rhs": "0",
          "expr": "margin <= 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None or reduce is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "margin <= 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.TripletMarginWithDistanceLoss": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "distance_function",
          "op": "is",
          "rhs": "None",
          "expr": "distance_function is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "swap",
          "op": "",
          "rhs": "",
          "expr": "swap",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "not in",
          "rhs": "('mean', 'sum', 'none')",
          "expr": "reduction not in ('mean', 'sum', 'none')",
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "margin",
          "op": "<=",
          "rhs": "0",
          "expr": "margin <= 0",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "distance_function is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "swap",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "reduction not in ('mean', 'sum', 'none')",
        "src": "python",
        "type": "membership_check"
      },
      {
        "expr": "margin <= 0",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.PixelShuffle": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.PixelUnshuffle": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Upsample": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'nearest'",
          "expr": "input.dim() == 3 and mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'nearest-exact'",
          "expr": "input.dim() == 4 and mode == 'nearest-exact'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'bicubic'",
          "expr": "input.dim() == 4 and mode == 'bicubic'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'area'",
          "expr": "input.dim() == 4 and mode == 'area'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'area'",
          "expr": "input.dim() == 5 and mode == 'area'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'nearest'",
          "expr": "input.dim() == 5 and mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'bilinear'",
          "expr": "input.dim() == 3 and mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'linear'",
          "expr": "input.dim() == 5 and mode == 'linear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None and recompute_scale_factor and (size is not None)",
          "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'area' and output_size is None",
          "expr": "mode == 'area' and output_size is None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "not None",
          "expr": "align_corners is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'trilinear'",
          "expr": "input.dim() == 3 and mode == 'trilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'bilinear'",
          "expr": "input.dim() == 5 and mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'linear'",
          "expr": "input.dim() == 4 and mode == 'linear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'nearest'",
          "expr": "input.dim() == 4 and mode == 'nearest'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'trilinear'",
          "expr": "input.dim() == 4 and mode == 'trilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'nearest-exact'",
          "expr": "input.dim() == 5 and mode == 'nearest-exact'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 and mode == 'bilinear'",
          "expr": "input.dim() == 4 and mode == 'bilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "in",
          "rhs": "('nearest', 'area', 'nearest-exact')",
          "expr": "mode in ('nearest', 'area', 'nearest-exact')",
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None and recompute_scale_factor",
          "expr": "recompute_scale_factor is not None and recompute_scale_factor",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'nearest-exact'",
          "expr": "input.dim() == 3 and mode == 'nearest-exact'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 and mode == 'trilinear'",
          "expr": "input.dim() == 5 and mode == 'trilinear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'area'",
          "expr": "input.dim() == 3 and mode == 'area'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 and mode == 'linear'",
          "expr": "input.dim() == 3 and mode == 'linear'",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None and scale_factor is not None",
          "expr": "size is not None and scale_factor is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "antialias and (not (mode",
          "op": "in",
          "rhs": "('bilinear', 'bicubic') and input.ndim == 4))",
          "expr": "antialias and (not (mode in ('bilinear', 'bicubic') and input.ndim == 4))",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'nearest-exact'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'bicubic'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'area'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'area'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'linear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "mode == 'area' and output_size is None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "align_corners is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'trilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'linear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'nearest'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'trilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'nearest-exact'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 4 and mode == 'bilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "mode in ('nearest', 'area', 'nearest-exact')",
        "src": "python",
        "type": "membership_check"
      },
      {
        "expr": "recompute_scale_factor is not None and recompute_scale_factor",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'nearest-exact'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 5 and mode == 'trilinear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'area'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "input.dim() == 3 and mode == 'linear'",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "size is not None and scale_factor is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "antialias and (not (mode in ('bilinear', 'bicubic') and input.ndim == 4))",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.UpsamplingNearest2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None and recompute_scale_factor and (size is not None)",
          "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None and scale_factor is not None",
          "expr": "size is not None and scale_factor is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size is not None and scale_factor is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.UpsamplingBilinear2d": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None and recompute_scale_factor and (size is not None)",
          "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None and scale_factor is not None",
          "expr": "size is not None and scale_factor is not None",
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "recompute_scale_factor is not None and recompute_scale_factor and (size is not None)",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check"
      },
      {
        "expr": "size is not None and scale_factor is not None",
        "src": "python",
        "type": "shape_check"
      }
    ]
  },
  "torch.nn.ChannelShuffle": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(c % groups)",
          "op": "==",
          "rhs": "0",
          "expr": "(c % groups) == 0",
          "type": "range_check",
          "src": "cpp"
        },
        {
          "lhs": "groups",
          "op": ">",
          "rhs": "0",
          "expr": "groups > 0",
          "type": "range_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(c % groups) == 0",
        "src": "cpp",
        "type": "range_check"
      },
      {
        "expr": "groups > 0",
        "src": "cpp",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.DataParallel": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not self.device_ids",
          "op": "",
          "rhs": "",
          "expr": "not self.device_ids",
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "len(self.device_ids)",
          "op": "==",
          "rhs": "1",
          "expr": "len(self.device_ids) == 1",
          "type": "device_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not self.device_ids",
        "src": "python",
        "type": "device_check"
      },
      {
        "expr": "len(self.device_ids) == 1",
        "src": "python",
        "type": "device_check"
      }
    ]
  },
  "torch.nn.parallel.DistributedDataParallel": {
    "type": "class",
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.device_ids",
          "op": "",
          "rhs": "",
          "expr": "self.device_ids",
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "self.find_unused_parameters and (not self.static_graph)",
          "op": "",
          "rhs": "",
          "expr": "self.find_unused_parameters and (not self.static_graph)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.find_unused_parameters and (not self.static_graph) or (self.static_graph and (not self._static_graph_delay_allreduce_enqueued))",
          "op": "",
          "rhs": "",
          "expr": "self.find_unused_parameters and (not self.static_graph) or (self.static_graph and (not self._static_graph_delay_allreduce_enqueued))",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.device_ids",
        "src": "python",
        "type": "device_check"
      },
      {
        "expr": "self.find_unused_parameters and (not self.static_graph)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "self.find_unused_parameters and (not self.static_graph) or (self.static_graph and (not self._static_graph_delay_allreduce_enqueued))",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.utils.clip_grad_norm_": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "error_if_nonfinite and torch.logical_or(total_norm.isnan(), total_norm.isinf())",
          "op": "",
          "rhs": "",
          "expr": "error_if_nonfinite and torch.logical_or(total_norm.isnan(), total_norm.isinf())",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "foreach",
          "op": "is",
          "rhs": "None and _has_foreach_support(device_grads, device) or (foreach and _device_has_foreach_support(device))",
          "expr": "foreach is None and _has_foreach_support(device_grads, device) or (foreach and _device_has_foreach_support(device))",
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(parameters, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(parameters, torch.Tensor)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "foreach",
          "op": "",
          "rhs": "",
          "expr": "foreach",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "error_if_nonfinite and torch.logical_or(total_norm.isnan(), total_norm.isinf())",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "foreach is None and _has_foreach_support(device_grads, device) or (foreach and _device_has_foreach_support(device))",
        "src": "python",
        "type": "device_check"
      },
      {
        "expr": "isinstance(parameters, torch.Tensor)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "foreach",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.utils.parameters_to_vector": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.utils.vector_to_parameters": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not isinstance(vec, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(vec, torch.Tensor)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not isinstance(vec, torch.Tensor)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.utils.weight_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.utils.remove_weight_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(hook, WeightNorm) and hook.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, WeightNorm) and hook.name == name",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(hook, WeightNorm) and hook.name == name",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.utils.spectral_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "existence_check"
      },
      {
        "expr": "isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.utils.remove_spectral_norm": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(hook, SpectralNormLoadStateDictPreHook) and hook.fn.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, SpectralNormLoadStateDictPreHook) and hook.fn.name == name",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(hook, SpectralNorm) and hook.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, SpectralNorm) and hook.name == name",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(hook, SpectralNormStateDictHook) and hook.fn.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, SpectralNormStateDictHook) and hook.fn.name == name",
          "type": "range_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(hook, SpectralNormLoadStateDictPreHook) and hook.fn.name == name",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(hook, SpectralNorm) and hook.name == name",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "isinstance(hook, SpectralNormStateDictHook) and hook.fn.name == name",
        "src": "python",
        "type": "range_check"
      }
    ]
  },
  "torch.nn.utils.rnn.pack_padded_sequence": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "not isinstance(lengths, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(lengths, torch.Tensor)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "enforce_sorted",
          "op": "",
          "rhs": "",
          "expr": "enforce_sorted",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not isinstance(lengths, torch.Tensor)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "enforce_sorted",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.utils.rnn.pad_packed_sequence": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "total_length",
          "op": "<",
          "rhs": "max_seq_length",
          "expr": "total_length < max_seq_length",
          "type": "range_check",
          "src": "python"
        },
        {
          "lhs": "total_length",
          "op": "is",
          "rhs": "not None",
          "expr": "total_length is not None",
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "total_length < max_seq_length",
        "src": "python",
        "type": "range_check"
      },
      {
        "expr": "total_length is not None",
        "src": "python",
        "type": "existence_check"
      }
    ]
  },
  "torch.nn.utils.rnn.pad_sequence": {
    "type": "function",
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(sequences, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(sequences, torch.Tensor)",
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "not isinstance(sequences, Iterable)",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(sequences, Iterable)",
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(sequences, torch.Tensor)",
        "src": "python",
        "type": "boolean"
      },
      {
        "expr": "not isinstance(sequences, Iterable)",
        "src": "python",
        "type": "boolean"
      }
    ]
  },
  "torch.nn.utils.rnn.pack_sequence": {
    "type": "function",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Flatten": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Unflatten": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.modules.lazy.LazyModuleMixin": {
    "type": "class",
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  }
}
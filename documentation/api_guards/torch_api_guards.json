{
  "torch.nn.functional.conv1d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.conv2d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.conv3d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.conv_transpose1d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.conv_transpose2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.conv_transpose3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.unfold": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.fold": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.avg_pool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.avg_pool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.avg_pool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_pool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_pool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQInt8",
          "expr": "(self_arg.scalar_type() == kQInt8",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQUInt8",
          "expr": "self_arg.scalar_type() == kQUInt8",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQInt8",
          "expr": "self_arg.scalar_type() == kQInt8",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQUInt8",
          "expr": "(self_arg.scalar_type() == kQUInt8",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self_arg.scalar_type() == kQInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self_arg.scalar_type() == kQUInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "self_arg.scalar_type() == kQInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(self_arg.scalar_type() == kQUInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.max_pool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.max_unpool1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(output_size, list)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(output_size, list)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(stride",
          "op": "is",
          "rhs": "not None",
          "expr": "(stride is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(isinstance(output_size, list)",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(output_size, list)",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(output_size, list)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(isinstance(output_size, list)",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.max_unpool2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(stride",
          "op": "is",
          "rhs": "not None",
          "expr": "(stride is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.max_unpool3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(stride",
          "op": "is",
          "rhs": "not None",
          "expr": "(stride is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.lp_pool1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(stride",
          "op": "is",
          "rhs": "not None",
          "expr": "(stride is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.lp_pool2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(stride",
          "op": "is",
          "rhs": "not None",
          "expr": "(stride is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.adaptive_max_pool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.adaptive_max_pool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.adaptive_max_pool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(input.ndimension()",
          "op": "==",
          "rhs": "4",
          "expr": "(input.ndimension() == 4",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.ndimension()",
          "op": "==",
          "rhs": "4",
          "expr": "input.ndimension() == 4",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.ndimension()",
          "op": "==",
          "rhs": "5",
          "expr": "(input.ndimension() == 5",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.ndimension()",
          "op": "==",
          "rhs": "5",
          "expr": "input.ndimension() == 5",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(input.ndimension() == 4",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.ndimension() == 4",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.ndimension() == 5",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.ndimension() == 5",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.adaptive_avg_pool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.adaptive_avg_pool2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "2",
          "expr": "output_size.size() == 2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.is_mkldnn()",
          "op": "",
          "rhs": "",
          "expr": "(input.is_mkldnn()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(output_size.size()",
          "op": "==",
          "rhs": "2",
          "expr": "(output_size.size() == 2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.suggest_memory_format()",
          "op": "==",
          "rhs": "at::MemoryFormat::ChannelsLast",
          "expr": "(input.suggest_memory_format() == at::MemoryFormat::ChannelsLast",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0",
          "expr": "(output_size[0] >= 0 && output_size[1] >= 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(!input.is_quantized() && output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1",
          "expr": "(!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.suggest_memory_format()",
          "op": "==",
          "rhs": "at::MemoryFormat::ChannelsLast",
          "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_mkldnn()",
          "op": "",
          "rhs": "",
          "expr": "input.is_mkldnn()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "!input.is_quantized() && output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1",
          "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "output_size.size() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.is_mkldnn()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(output_size.size() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.suggest_memory_format() == at::MemoryFormat::ChannelsLast",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(output_size[0] >= 0 && output_size[1] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "input.is_mkldnn()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.adaptive_avg_pool3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0 && output_size[2] >= 0",
          "expr": "(output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size.size()",
          "op": "==",
          "rhs": "3",
          "expr": "(output_size.size() == 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1 && output_size[2] == 1",
          "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0 && output_size[2] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "3",
          "expr": "output_size.size() == 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1 && output_size[2] == 1",
          "expr": "(output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.suggest_memory_format()",
          "op": "==",
          "rhs": "at::MemoryFormat::ChannelsLast3d",
          "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast3d",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.suggest_memory_format()",
          "op": "==",
          "rhs": "at::MemoryFormat::ChannelsLast3d",
          "expr": "(input.suggest_memory_format() == at::MemoryFormat::ChannelsLast3d",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(output_size.size() == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "output_size.size() == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.suggest_memory_format() == at::MemoryFormat::ChannelsLast3d",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(input.suggest_memory_format() == at::MemoryFormat::ChannelsLast3d",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.threshold": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.threshold_": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.relu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(self.scalar_type()",
          "op": "!=",
          "rhs": "at::kBool",
          "expr": "(self.scalar_type() != at::kBool",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self.scalar_type()",
          "op": "!=",
          "rhs": "at::kBool",
          "expr": "self.scalar_type() != at::kBool",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(self.scalar_type() != at::kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self.scalar_type() != at::kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.relu_": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self.scalar_type()",
          "op": "!=",
          "rhs": "at::kBool",
          "expr": "(self.scalar_type() != at::kBool",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self.scalar_type()",
          "op": "!=",
          "rhs": "at::kBool",
          "expr": "self.scalar_type() != at::kBool",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self.scalar_type() != at::kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self.scalar_type() != at::kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.hardtanh": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(min_val",
          "op": ">",
          "rhs": "max_val",
          "expr": "(min_val > max_val",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(min_val > max_val",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.hardtanh_": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardswish": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.relu6": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.elu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.elu_": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.selu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.celu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "alpha.to",
          "op": "<",
          "rhs": "double>() != 0",
          "expr": "alpha.to<double>() != 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(alpha.to",
          "op": "<",
          "rhs": "double>() != 0",
          "expr": "(alpha.to<double>() != 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "alpha.to<double>() != 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(alpha.to<double>() != 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.leaky_relu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.leaky_relu_": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.prelu": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.rrelu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.rrelu_": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.glu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "(input.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(input.dim() == 0",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.gelu": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.logsigmoid": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardshrink": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.tanhshrink": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.softsign": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.softplus": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.softmin": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(dtype",
          "op": "is",
          "rhs": "None",
          "expr": "(dtype is None",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(dim",
          "op": "is",
          "rhs": "None",
          "expr": "(dim is None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.softmax": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(dtype",
          "op": "is",
          "rhs": "None",
          "expr": "(dtype is None",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(dim",
          "op": "is",
          "rhs": "None",
          "expr": "(dim is None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.softshrink": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.gumbel_softmax": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "hard",
          "op": "",
          "rhs": "",
          "expr": "hard",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(eps",
          "op": "!=",
          "rhs": "1e-10",
          "expr": "(eps != 1e-10",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(hard",
          "op": "",
          "rhs": "",
          "expr": "(hard",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(logits)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(logits)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(logits)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(logits)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "eps",
          "op": "!=",
          "rhs": "1e-10",
          "expr": "eps != 1e-10",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "hard",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(eps != 1e-10",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(hard",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(has_torch_function_unary(logits)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(logits)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "eps != 1e-10",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.log_softmax": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(dtype",
          "op": "is",
          "rhs": "None",
          "expr": "(dtype is None",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(dim",
          "op": "is",
          "rhs": "None",
          "expr": "(dim is None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.tanh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.sigmoid": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.hardsigmoid": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.silu": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(inplace",
          "op": "",
          "rhs": "",
          "expr": "(inplace",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(inplace",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.batch_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(training",
          "op": "",
          "rhs": "",
          "expr": "(training",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "training",
          "op": "",
          "rhs": "",
          "expr": "training",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(training",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "training",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.instance_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "use_input_stats",
          "op": "",
          "rhs": "",
          "expr": "use_input_stats",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(use_input_stats",
          "op": "",
          "rhs": "",
          "expr": "(use_input_stats",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "use_input_stats",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(use_input_stats",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, running_mean, running_var, weight, bias)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.layer_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, weight, bias)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, weight, bias)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, weight, bias)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input, weight, bias)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, weight, bias)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.local_response_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "(input.numel() == 0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "input.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "input.numel() == 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(input.numel() == 0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "input.numel() == 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.normalize": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function_variadic(input, out)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, out)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(out",
          "op": "is",
          "rhs": "None",
          "expr": "(out is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, out)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, out)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function_variadic(input, out)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(out is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, out)",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.linear": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "input_dim",
          "op": "!=",
          "rhs": "0 && weight_dim != 0",
          "expr": "input_dim != 0 && weight_dim != 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.is_mkldnn()",
          "op": "",
          "rhs": "",
          "expr": "(input.is_mkldnn()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "(bias->defined() && !input.is_xla()",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_mkldnn()",
          "op": "",
          "rhs": "",
          "expr": "input.is_mkldnn()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input_dim",
          "op": "==",
          "rhs": "3",
          "expr": "input.is_contiguous() && input_dim == 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(parseLinearFlatten3d() && input_dim",
          "op": "==",
          "rhs": "3",
          "expr": "(parseLinearFlatten3d() && input_dim == 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.is_contiguous() && input_dim",
          "op": "==",
          "rhs": "3",
          "expr": "(input.is_contiguous() && input_dim == 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "bias->defined()",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "parseLinearFlatten3d() && input_dim",
          "op": "==",
          "rhs": "3",
          "expr": "parseLinearFlatten3d() && input_dim == 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "(input_dim == 2 && bias->defined()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input_dim",
          "op": "!=",
          "rhs": "0 && weight_dim != 0",
          "expr": "(input_dim != 0 && weight_dim != 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "input_dim == 2 && bias->defined()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "(input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "bias->defined() && !input.is_xla()",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "(bias->defined()",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "input_dim != 0 && weight_dim != 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.is_mkldnn()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "input.is_mkldnn()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "input.is_contiguous() && input_dim == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(parseLinearFlatten3d() && input_dim == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.is_contiguous() && input_dim == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "bias->defined()",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "parseLinearFlatten3d() && input_dim == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input_dim != 0 && weight_dim != 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(bias->defined()",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.bilinear": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.dropout": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "(p < 0.0 || p > 1.0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.alpha_dropout": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "(p < 0.0 || p > 1.0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.feature_alpha_dropout": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "(p < 0.0 || p > 1.0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.dropout2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "(p < 0.0 || p > 1.0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(inp_dim",
          "op": "==",
          "rhs": "3",
          "expr": "(inp_dim == 3",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(inp_dim",
          "op": "not in",
          "rhs": "(3, 4)",
          "expr": "(inp_dim not in (3, 4)",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "inp_dim",
          "op": "not in",
          "rhs": "(3, 4)",
          "expr": "inp_dim not in (3, 4)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "inp_dim",
          "op": "==",
          "rhs": "3",
          "expr": "inp_dim == 3",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(inp_dim == 3",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(inp_dim not in (3, 4)",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "inp_dim not in (3, 4)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "inp_dim == 3",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.dropout3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "(p < 0.0 || p > 1.0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(inp_dim",
          "op": "not in",
          "rhs": "(4, 5)",
          "expr": "(inp_dim not in (4, 5)",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inp_dim",
          "op": "not in",
          "rhs": "(4, 5)",
          "expr": "inp_dim not in (4, 5)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(inp_dim not in (4, 5)",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "inp_dim not in (4, 5)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.embedding": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "padding_idx",
          "op": "is",
          "rhs": "not None",
          "expr": "padding_idx is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": ">",
          "rhs": "0",
          "expr": "padding_idx > 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": "<",
          "rhs": "0",
          "expr": "padding_idx < 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": "<",
          "rhs": "weight.size(0)",
          "expr": "padding_idx < weight.size(0)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(padding_idx",
          "op": "<",
          "rhs": "0",
          "expr": "(padding_idx < 0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(padding_idx",
          "op": "is",
          "rhs": "not None",
          "expr": "(padding_idx is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": ">=",
          "rhs": "-weight.size(0)",
          "expr": "padding_idx >= -weight.size(0)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "(max_norm is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(padding_idx",
          "op": ">",
          "rhs": "0",
          "expr": "(padding_idx > 0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "weight.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "weight.dim() == 2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(weight.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "(weight.dim() == 2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "padding_idx is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "padding_idx > 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "padding_idx < 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "padding_idx < weight.size(0)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(padding_idx < 0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(padding_idx is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "padding_idx >= -weight.size(0)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(max_norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(padding_idx > 0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "weight.dim() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(weight.dim() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.embedding_bag": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not weight.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "(not weight.dim() == 2",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "input.dim() == 2",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'mean'",
          "expr": "mode == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(sparse",
          "op": "",
          "rhs": "",
          "expr": "(sparse",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(offsets",
          "op": "is",
          "rhs": "None",
          "expr": "(offsets is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "1",
          "expr": "input.dim() == 1",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "==",
          "rhs": "'sum'",
          "expr": "(mode == 'sum'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(per_sample_weights",
          "op": "is",
          "rhs": "not None && mode != 'sum'",
          "expr": "(per_sample_weights is not None && mode != 'sum'",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'max'",
          "expr": "mode == 'max'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(weight.dtype",
          "op": "==",
          "rhs": "torch.long && input.is_floating_point()",
          "expr": "(weight.dtype == torch.long && input.is_floating_point()",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "(per_sample_weights",
          "op": "is",
          "rhs": "not None",
          "expr": "(per_sample_weights is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "(max_norm is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(per_sample_weights",
          "op": "is",
          "rhs": "not None && input.size() != per_sample_weights.size()",
          "expr": "(per_sample_weights is not None && input.size() != per_sample_weights.size()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(offsets.dim()",
          "op": "!=",
          "rhs": "1",
          "expr": "(offsets.dim() != 1",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(offsets",
          "op": "is",
          "rhs": "not None",
          "expr": "(offsets is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "==",
          "rhs": "'mean'",
          "expr": "(mode == 'mean'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "per_sample_weights",
          "op": "is",
          "rhs": "not None",
          "expr": "per_sample_weights is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "(input.dim() == 2",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight.dtype",
          "op": "==",
          "rhs": "torch.long && input.is_floating_point()",
          "expr": "weight.dtype == torch.long && input.is_floating_point()",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "(scale_grad_by_freq",
          "op": "",
          "rhs": "",
          "expr": "(scale_grad_by_freq",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'sum'",
          "expr": "mode == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(not weight.dim() == 2",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "input.dim() == 2",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "mode == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(sparse",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(offsets is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 1",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(mode == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(per_sample_weights is not None && mode != 'sum'",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "mode == 'max'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(weight.dtype == torch.long && input.is_floating_point()",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(per_sample_weights is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(max_norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(per_sample_weights is not None && input.size() != per_sample_weights.size()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(offsets.dim() != 1",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(offsets is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(mode == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, weight, offsets, per_sample_weights)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "per_sample_weights is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 2",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "weight.dtype == torch.long && input.is_floating_point()",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "(scale_grad_by_freq",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "mode == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.one_hot": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pairwise_distance": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.cosine_similarity": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pdist": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.binary_cross_entropy": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(weight",
          "op": "is",
          "rhs": "not None",
          "expr": "(weight is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target, weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(target.size()",
          "op": "!=",
          "rhs": "input.size()",
          "expr": "(target.size() != input.size()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(target.size() != input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.binary_cross_entropy_with_logits": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "(not target.size() == input.size()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target, weight, pos_weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target, weight, pos_weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(pos_weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "(pos_weight.defined()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "weight.defined()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "(weight.defined()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "pos_weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "pos_weight.defined()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target, weight, pos_weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(pos_weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "pos_weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.poisson_nll_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(reduction",
          "op": "!=",
          "rhs": "'none' && reduction != 'mean' && (reduction != 'sum')",
          "expr": "(reduction != 'none' && reduction != 'mean' && (reduction != 'sum')",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(reduction != 'none' && reduction != 'mean' && (reduction != 'sum')",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.cosine_embedding_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(input1, input2, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input1, input2, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input1, input2, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input1, input2, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(input1, input2, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input1, input2, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.cross_entropy": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target, weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.ctc_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(log_probs, targets, input_lengths, target_lengths)",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.hinge_embedding_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.kl_div": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean' && input.dim() != 0",
          "expr": "reduction == 'batchmean' && input.dim() != 0",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'batchmean'",
          "expr": "(reduction == 'batchmean'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean'",
          "expr": "reduction == 'batchmean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "(reduction == 'mean'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'batchmean' && input.dim() != 0",
          "expr": "(reduction == 'batchmean' && input.dim() != 0",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "reduction == 'batchmean' && input.dim() != 0",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(reduction == 'batchmean'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "reduction == 'batchmean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(reduction == 'batchmean' && input.dim() != 0",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.l1_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "(not target.size() == input.size()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.mse_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "(not target.size() == input.size()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "(reduction == Reduction::Mean",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "(reduction != Reduction::None",
          "negated": true,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "negated": false,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.margin_ranking_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input1, input2, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input1, input2, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input1, input2, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input1, input2, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input1.dim()",
          "op": "!=",
          "rhs": "input2.dim() || input1.dim() != target.dim()",
          "expr": "(input1.dim() != input2.dim() || input1.dim() != target.dim()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input1, input2, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input1, input2, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(input1.dim() != input2.dim() || input1.dim() != target.dim()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.multilabel_margin_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.multilabel_soft_margin_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'none'",
          "expr": "reduction == 'none'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(weight",
          "op": "is",
          "rhs": "not None",
          "expr": "(weight is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target, weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "(reduction == 'mean'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'none'",
          "expr": "(reduction == 'none'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "reduction == 'none'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(reduction == 'none'",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.multi_margin_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(weight",
          "op": "is",
          "rhs": "not None",
          "expr": "(weight is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(weight.dim()",
          "op": "!=",
          "rhs": "1",
          "expr": "(weight.dim() != 1",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(p",
          "op": "!=",
          "rhs": "1 && p != 2",
          "expr": "(p != 1 && p != 2",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target, weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(weight.dim() != 1",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(p != 1 && p != 2",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.nll_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target, weight)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.smooth_l1_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "(not target.size() == input.size()",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not target.size()",
          "op": "==",
          "rhs": "input.size()",
          "expr": "not target.size() == input.size()",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "beta",
          "op": "==",
          "rhs": "0.0",
          "expr": "beta == 0.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(beta",
          "op": "==",
          "rhs": "0.0",
          "expr": "(beta == 0.0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "(reduction == Reduction::Mean",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "(reduction != Reduction::None",
          "negated": true,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "negated": false,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "not target.size() == input.size()",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "beta == 0.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(beta == 0.0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.soft_margin_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, target)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, target)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.triplet_margin_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(anchor, positive, negative)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "(size_average is not None || reduce is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(anchor, positive, negative)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(margin",
          "op": "<=",
          "rhs": "0",
          "expr": "(margin <= 0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(margin <= 0",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.triplet_margin_with_distance_loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(swap",
          "op": "",
          "rhs": "",
          "expr": "(swap",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(anchor, positive, negative)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "not in",
          "rhs": "('mean', 'sum', 'none')",
          "expr": "(reduction not in ('mean', 'sum', 'none')",
          "negated": true,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "(reduction == 'sum'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "swap",
          "op": "",
          "rhs": "",
          "expr": "swap",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "distance_function",
          "op": "is",
          "rhs": "None",
          "expr": "distance_function is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "(reduction == 'mean'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(distance_function",
          "op": "is",
          "rhs": "None",
          "expr": "(distance_function is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(anchor, positive, negative)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(margin",
          "op": "<=",
          "rhs": "0",
          "expr": "(margin <= 0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(swap",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(reduction not in ('mean', 'sum', 'none')",
        "src": "python",
        "type": "membership_check",
        "negated": true
      },
      {
        "expr": "(reduction == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "swap",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "distance_function is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(distance_function is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(margin <= 0",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.pixel_shuffle": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pixel_unshuffle": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.pad": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "op": "",
          "rhs": "",
          "expr": "torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'replicate'",
          "expr": "mode == 'replicate'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "==",
          "rhs": "'replicate'",
          "expr": "(mode == 'replicate'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "op": "",
          "rhs": "",
          "expr": "(torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "mode == 'replicate'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(mode == 'replicate'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.functional.interpolate": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'nearest'",
          "expr": "input.dim() == 5 && mode == 'nearest'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'nearest'",
          "expr": "(input.dim() == 5 && mode == 'nearest'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'nearest'",
          "expr": "(input.dim() == 4 && mode == 'nearest'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'nearest'",
          "expr": "(input.dim() == 3 && mode == 'nearest'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "(len(scale_factor) != dim",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'bilinear'",
          "expr": "input.dim() == 4 && mode == 'bilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "not None",
          "expr": "align_corners is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "output_size",
          "op": "is",
          "rhs": "not None",
          "expr": "output_size is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "in",
          "rhs": "('nearest', 'area', 'nearest-exact')",
          "expr": "mode in ('nearest', 'area', 'nearest-exact')",
          "negated": false,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'trilinear'",
          "expr": "(input.dim() == 5 && mode == 'trilinear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(scale_factor, (list, tuple))",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'bilinear'",
          "expr": "(input.dim() == 5 && mode == 'bilinear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor",
          "expr": "(recompute_scale_factor is not None && recompute_scale_factor",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'nearest-exact'",
          "expr": "input.dim() == 3 && mode == 'nearest-exact'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'nearest'",
          "expr": "input.dim() == 3 && mode == 'nearest'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'bicubic'",
          "expr": "(input.dim() == 4 && mode == 'bicubic'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "(align_corners is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'nearest-exact'",
          "expr": "(input.dim() == 4 && mode == 'nearest-exact'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'bilinear'",
          "expr": "(input.dim() == 4 && mode == 'bilinear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(align_corners",
          "op": "is",
          "rhs": "not None",
          "expr": "(align_corners is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'bilinear'",
          "expr": "(input.dim() == 3 && mode == 'bilinear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'area' && output_size is None",
          "expr": "mode == 'area' && output_size is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "in",
          "rhs": "('nearest', 'area', 'nearest-exact')",
          "expr": "(mode in ('nearest', 'area', 'nearest-exact')",
          "negated": true,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'area'",
          "expr": "input.dim() == 3 && mode == 'area'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(size, (list, tuple))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor && (size is not None)",
          "expr": "(recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "op": "",
          "rhs": "",
          "expr": "torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'nearest-exact'",
          "expr": "input.dim() == 4 && mode == 'nearest-exact'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(size",
          "op": "is",
          "rhs": "not None",
          "expr": "(size is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'trilinear'",
          "expr": "(input.dim() == 3 && mode == 'trilinear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'area'",
          "expr": "input.dim() == 5 && mode == 'area'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'linear'",
          "expr": "(input.dim() == 5 && mode == 'linear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(antialias",
          "op": "",
          "rhs": "",
          "expr": "(antialias",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'trilinear'",
          "expr": "(input.dim() == 4 && mode == 'trilinear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'linear'",
          "expr": "(input.dim() == 3 && mode == 'linear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "None",
          "expr": "size is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "(not all((_is_integer(x) for x in size))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'area'",
          "expr": "(input.dim() == 5 && mode == 'area'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'bicubic'",
          "expr": "input.dim() == 4 && mode == 'bicubic'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'area'",
          "expr": "(input.dim() == 3 && mode == 'area'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "(len(size) != dim",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'area'",
          "expr": "(input.dim() == 4 && mode == 'area'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'linear'",
          "expr": "input.dim() == 3 && mode == 'linear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'trilinear'",
          "expr": "input.dim() == 5 && mode == 'trilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'nearest-exact'",
          "expr": "(input.dim() == 3 && mode == 'nearest-exact'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "==",
          "rhs": "'area' && output_size is None",
          "expr": "(mode == 'area' && output_size is None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factors",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factors is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(size",
          "op": "is",
          "rhs": "not None && scale_factor is not None",
          "expr": "(size is not None && scale_factor is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(antialias && (not (mode",
          "op": "in",
          "rhs": "('bilinear', 'bicubic') && input.ndim == 4))",
          "expr": "(antialias && (not (mode in ('bilinear', 'bicubic') && input.ndim == 4))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'nearest-exact'",
          "expr": "(input.dim() == 5 && mode == 'nearest-exact'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'nearest-exact'",
          "expr": "input.dim() == 5 && mode == 'nearest-exact'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'area'",
          "expr": "input.dim() == 4 && mode == 'area'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "antialias",
          "op": "",
          "rhs": "",
          "expr": "antialias",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'linear'",
          "expr": "(input.dim() == 4 && mode == 'linear'",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "op": "",
          "rhs": "",
          "expr": "(torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'nearest'",
          "expr": "input.dim() == 4 && mode == 'nearest'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "None",
          "expr": "scale_factor is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.dim() == 5 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 5 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 4 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 3 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(len(scale_factor) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 4 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "align_corners is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "output_size is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "mode in ('nearest', 'area', 'nearest-exact')",
        "src": "python",
        "type": "membership_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 5 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(input.dim() == 5 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(recompute_scale_factor is not None && recompute_scale_factor",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 3 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 4 && mode == 'bicubic'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 4 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 4 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(align_corners is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 3 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "mode == 'area' && output_size is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(mode in ('nearest', 'area', 'nearest-exact')",
        "src": "python",
        "type": "membership_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 3 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(size is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 3 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 5 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(antialias",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(input.dim() == 4 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 3 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "size is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 5 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 4 && mode == 'bicubic'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 3 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(len(size) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 4 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 3 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.dim() == 3 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(mode == 'area' && output_size is None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "scale_factors is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(size is not None && scale_factor is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(antialias && (not (mode in ('bilinear', 'bicubic') && input.ndim == 4))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(input.dim() == 5 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.dim() == 5 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "antialias",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(input.dim() == 4 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(torch.are_deterministic_algorithms_enabled() && (input.is_cuda || input.is_xpu)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "scale_factor is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.upsample": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.upsample_nearest": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.upsample_bilinear": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.functional.grid_sample": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "padding_mode",
          "op": "==",
          "rhs": "'border'",
          "expr": "padding_mode == 'border'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'nearest'",
          "expr": "mode == 'nearest'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(padding_mode",
          "op": "!=",
          "rhs": "'zeros' && padding_mode != 'border' && (padding_mode != 'reflection')",
          "expr": "(padding_mode != 'zeros' && padding_mode != 'border' && (padding_mode != 'reflection')",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "==",
          "rhs": "'nearest'",
          "expr": "(mode == 'nearest'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, grid)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, grid)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "!=",
          "rhs": "'bilinear' && mode != 'nearest' && (mode != 'bicubic')",
          "expr": "(mode != 'bilinear' && mode != 'nearest' && (mode != 'bicubic')",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(padding_mode",
          "op": "==",
          "rhs": "'zeros'",
          "expr": "(padding_mode == 'zeros'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(mode",
          "op": "==",
          "rhs": "'bilinear'",
          "expr": "(mode == 'bilinear'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'bilinear'",
          "expr": "mode == 'bilinear'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(padding_mode",
          "op": "==",
          "rhs": "'border'",
          "expr": "(padding_mode == 'border'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(input, grid)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(input, grid)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "(align_corners is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "padding_mode",
          "op": "==",
          "rhs": "'zeros'",
          "expr": "padding_mode == 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "padding_mode == 'border'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "mode == 'nearest'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(padding_mode != 'zeros' && padding_mode != 'border' && (padding_mode != 'reflection')",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(mode == 'nearest'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(input, grid)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(mode != 'bilinear' && mode != 'nearest' && (mode != 'bicubic')",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(padding_mode == 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(mode == 'bilinear'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "mode == 'bilinear'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(padding_mode == 'border'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(input, grid)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "padding_mode == 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.functional.affine_grid": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "len(size)",
          "op": "==",
          "rhs": "4",
          "expr": "len(size) == 4",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(len(size)",
          "op": "==",
          "rhs": "4",
          "expr": "(len(size) == 4",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(theta)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(theta)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(align_corners && min(spatial_size)",
          "op": "==",
          "rhs": "1",
          "expr": "(align_corners && min(spatial_size) == 1",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(not theta.is_floating_point()",
          "op": "",
          "rhs": "",
          "expr": "(not theta.is_floating_point()",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "(align_corners is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "align_corners && min(spatial_size)",
          "op": "==",
          "rhs": "1",
          "expr": "align_corners && min(spatial_size) == 1",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "==",
          "rhs": "5",
          "expr": "len(size) == 5",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(min(size)",
          "op": "<=",
          "rhs": "0",
          "expr": "(min(size) <= 0",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(theta.dim()",
          "op": "!=",
          "rhs": "3 || theta.shape[-2] != 2 || theta.shape[-1] != 3",
          "expr": "(theta.dim() != 3 || theta.shape[-2] != 2 || theta.shape[-1] != 3",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(theta)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(theta)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(theta.dim()",
          "op": "!=",
          "rhs": "3 || theta.shape[-2] != 3 || theta.shape[-1] != 4",
          "expr": "(theta.dim() != 3 || theta.shape[-2] != 3 || theta.shape[-1] != 4",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "len(size) == 4",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(len(size) == 4",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(theta)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(align_corners && min(spatial_size) == 1",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(not theta.is_floating_point()",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "(align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "align_corners && min(spatial_size) == 1",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(size) == 5",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(min(size) <= 0",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(theta.dim() != 3 || theta.shape[-2] != 2 || theta.shape[-1] != 3",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_unary(theta)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(theta.dim() != 3 || theta.shape[-2] != 3 || theta.shape[-1] != 4",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.is_tensor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.is_storage": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.is_complex": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.is_floating_point": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.is_nonzero": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_default_dtype": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.get_default_dtype": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_default_tensor_type": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(t, str)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(t, str)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(isinstance(t, str)",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(t, str)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(t, str)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(isinstance(t, str)",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.numel": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_printoptions": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "profile",
          "op": "is",
          "rhs": "not None",
          "expr": "profile is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "profile",
          "op": "==",
          "rhs": "'default'",
          "expr": "profile == 'default'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "edgeitems",
          "op": "is",
          "rhs": "not None",
          "expr": "edgeitems is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "threshold",
          "op": "is",
          "rhs": "not None",
          "expr": "threshold is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(profile",
          "op": "==",
          "rhs": "'default'",
          "expr": "(profile == 'default'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(precision",
          "op": "is",
          "rhs": "not None",
          "expr": "(precision is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(profile",
          "op": "is",
          "rhs": "not None",
          "expr": "(profile is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(edgeitems",
          "op": "is",
          "rhs": "not None",
          "expr": "(edgeitems is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(profile",
          "op": "==",
          "rhs": "'short'",
          "expr": "(profile == 'short'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(profile",
          "op": "==",
          "rhs": "'full'",
          "expr": "(profile == 'full'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(linewidth",
          "op": "is",
          "rhs": "not None",
          "expr": "(linewidth is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "linewidth",
          "op": "is",
          "rhs": "not None",
          "expr": "linewidth is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "precision",
          "op": "is",
          "rhs": "not None",
          "expr": "precision is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "profile",
          "op": "==",
          "rhs": "'full'",
          "expr": "profile == 'full'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(threshold",
          "op": "is",
          "rhs": "not None",
          "expr": "(threshold is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "profile",
          "op": "==",
          "rhs": "'short'",
          "expr": "profile == 'short'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "profile is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "profile == 'default'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "edgeitems is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "threshold is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(profile == 'default'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(precision is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(profile is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(edgeitems is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(profile == 'short'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(profile == 'full'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(linewidth is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "linewidth is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "precision is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "profile == 'full'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(threshold is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "profile == 'short'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.set_flush_denormal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.rand": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.rand_like": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.randn": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.randn_like": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.randint": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.randint_like": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.randperm": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(!dtype.has_value()",
          "op": "",
          "rhs": "",
          "expr": "(!dtype.has_value()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "!dtype.has_value()",
          "op": "",
          "rhs": "",
          "expr": "!dtype.has_value()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(!dtype.has_value()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "!dtype.has_value()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.empty": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
          "op": "",
          "rhs": "",
          "expr": "(options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
          "negated": true,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
          "op": "",
          "rhs": "",
          "expr": "options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
          "negated": false,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "(options.layout()",
          "op": "==",
          "rhs": "Layout::Strided",
          "expr": "(options.layout() == Layout::Strided",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "options.layout()",
          "op": "==",
          "rhs": "Layout::Strided",
          "expr": "options.layout() == Layout::Strided",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
        "src": "cpp",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "options.device().is_cpu() || options.device().is_cuda() || options.device().is_xpu() || options.device().is_privateuseone()",
        "src": "cpp",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "(options.layout() == Layout::Strided",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "options.layout() == Layout::Strided",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.tensor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sparse_coo_tensor": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "indices.numel()",
          "op": ">",
          "rhs": "0",
          "expr": "indices.numel() > 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(!indices.is_sparse()",
          "op": "",
          "rhs": "",
          "expr": "(!indices.is_sparse()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(indices.numel()",
          "op": ">",
          "rhs": "0",
          "expr": "(indices.numel() > 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "indices.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "indices.dim() == 2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(indices.dim()",
          "op": "==",
          "rhs": "2",
          "expr": "(indices.dim() == 2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "!indices.is_sparse()",
          "op": "",
          "rhs": "",
          "expr": "!indices.is_sparse()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "indices.numel() > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(!indices.is_sparse()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(indices.numel() > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "indices.dim() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(indices.dim() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "!indices.is_sparse()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.as_tensor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.as_strided": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.from_numpy": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.zeros": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "at::sparse_csr::is_sparse_compressed(layout_)",
          "op": "",
          "rhs": "",
          "expr": "at::sparse_csr::is_sparse_compressed(layout_)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(at::sparse_csr::is_sparse_compressed(layout_)",
          "op": "",
          "rhs": "",
          "expr": "(at::sparse_csr::is_sparse_compressed(layout_)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "at::sparse_csr::is_sparse_compressed(layout_)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(at::sparse_csr::is_sparse_compressed(layout_)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.zeros_like": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(optional_memory_format.has_value()",
          "op": "",
          "rhs": "",
          "expr": "(optional_memory_format.has_value()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "optional_memory_format.has_value()",
          "op": "",
          "rhs": "",
          "expr": "optional_memory_format.has_value()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "self.layout()",
          "op": "==",
          "rhs": "kSparseBsr || self.layout() == kSparseBsc",
          "expr": "self.layout() == kSparseBsr || self.layout() == kSparseBsc",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "options.layout()",
          "op": "==",
          "rhs": "kSparse",
          "expr": "options.layout() == kSparse",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::sparse_csr::is_sparse_compressed(options.layout())",
          "op": "",
          "rhs": "",
          "expr": "(at::sparse_csr::is_sparse_compressed(options.layout())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "at::sparse_csr::is_sparse_compressed(options.layout())",
          "op": "",
          "rhs": "",
          "expr": "at::sparse_csr::is_sparse_compressed(options.layout())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(self.layout()",
          "op": "==",
          "rhs": "kSparseBsr || self.layout() == kSparseBsc",
          "expr": "(self.layout() == kSparseBsr || self.layout() == kSparseBsc",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(options.layout()",
          "op": "==",
          "rhs": "kSparse",
          "expr": "(options.layout() == kSparse",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(optional_memory_format.has_value()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "optional_memory_format.has_value()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "self.layout() == kSparseBsr || self.layout() == kSparseBsc",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "options.layout() == kSparse",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(at::sparse_csr::is_sparse_compressed(options.layout())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "at::sparse_csr::is_sparse_compressed(options.layout())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(self.layout() == kSparseBsr || self.layout() == kSparseBsc",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(options.layout() == kSparse",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.ones": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ones_like": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arange": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.range": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.linspace": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "start.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "start.dim() == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(start.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "(start.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(steps",
          "op": ">=",
          "rhs": "0",
          "expr": "(steps >= 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "start.dim()",
          "op": "==",
          "rhs": "0 && end.dim() == 0",
          "expr": "start.dim() == 0 && end.dim() == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "end.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "end.dim() == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "steps",
          "op": ">=",
          "rhs": "0",
          "expr": "steps >= 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(end.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "(end.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(start.dim()",
          "op": "==",
          "rhs": "0 && end.dim() == 0",
          "expr": "(start.dim() == 0 && end.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "start.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(start.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(steps >= 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "start.dim() == 0 && end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "steps >= 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(start.dim() == 0 && end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.logspace": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "start.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "start.dim() == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(start.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "(start.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(steps",
          "op": ">=",
          "rhs": "0",
          "expr": "(steps >= 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "start.dim()",
          "op": "==",
          "rhs": "0 && end.dim() == 0",
          "expr": "start.dim() == 0 && end.dim() == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "end.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "end.dim() == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "steps",
          "op": ">=",
          "rhs": "0",
          "expr": "steps >= 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(end.dim()",
          "op": "==",
          "rhs": "0",
          "expr": "(end.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(start.dim()",
          "op": "==",
          "rhs": "0 && end.dim() == 0",
          "expr": "(start.dim() == 0 && end.dim() == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "start.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(start.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(steps >= 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "start.dim() == 0 && end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "steps >= 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(start.dim() == 0 && end.dim() == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.eye": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.empty_like": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.empty_strided": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.full": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(options.layout()",
          "op": "!=",
          "rhs": "kSparse",
          "expr": "(options.layout() != kSparse",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "options.layout()",
          "op": "!=",
          "rhs": "kSparse",
          "expr": "options.layout() != kSparse",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(options.layout() != kSparse",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "options.layout() != kSparse",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.full_like": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.quantize_per_tensor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.quantize_per_channel": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.dequantize": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.complex": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.imag": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.polar": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.angle": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.heaviside": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cat": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.chunk": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "chunks",
          "op": ">",
          "rhs": "0",
          "expr": "chunks > 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "(self.dim() > 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(chunks",
          "op": ">",
          "rhs": "0",
          "expr": "(chunks > 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(split_size",
          "op": "==",
          "rhs": "0 && dim_size == 0",
          "expr": "(split_size == 0 && dim_size == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "split_size",
          "op": "==",
          "rhs": "0 && dim_size == 0",
          "expr": "split_size == 0 && dim_size == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "self.dim() > 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "chunks > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(chunks > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(split_size == 0 && dim_size == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "split_size == 0 && dim_size == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.column_stack": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.dstack": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.gather": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(out_tensor.sizes()",
          "op": "==",
          "rhs": "expected_size",
          "expr": "(out_tensor.sizes() == expected_size",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "can_use_expanded_index_path(result, dim, index, self, /*is_scatter_like=*/false)",
          "op": "",
          "rhs": "",
          "expr": "can_use_expanded_index_path(result, dim, index, self, /*is_scatter_like=*/false)",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "tensor.ndimension()",
          "op": "==",
          "rhs": "static_cast<int64_t>(expected_size.size())",
          "expr": "tensor.ndimension() == static_cast<int64_t>(expected_size.size())",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "out_tensor.sizes()",
          "op": "==",
          "rhs": "expected_size",
          "expr": "out_tensor.sizes() == expected_size",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(can_use_expanded_index_path(result, dim, index, self, /*is_scatter_like=*/false)",
          "op": "",
          "rhs": "",
          "expr": "(can_use_expanded_index_path(result, dim, index, self, /*is_scatter_like=*/false)",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(tensor.ndimension()",
          "op": "==",
          "rhs": "static_cast<int64_t>(expected_size.size())",
          "expr": "(tensor.ndimension() == static_cast<int64_t>(expected_size.size())",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "index.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "index.numel() == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(index.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "(index.numel() == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "expected_size[dimension]",
          "op": "==",
          "rhs": "tensor.size(dimension)",
          "expr": "expected_size[dimension] == tensor.size(dimension)",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(expected_size[dimension]",
          "op": "==",
          "rhs": "tensor.size(dimension)",
          "expr": "(expected_size[dimension] == tensor.size(dimension)",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(out_tensor.sizes() == expected_size",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "can_use_expanded_index_path(result, dim, index, self, /*is_scatter_like=*/false)",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "tensor.ndimension() == static_cast<int64_t>(expected_size.size())",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "out_tensor.sizes() == expected_size",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(can_use_expanded_index_path(result, dim, index, self, /*is_scatter_like=*/false)",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(tensor.ndimension() == static_cast<int64_t>(expected_size.size())",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "index.numel() == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(index.numel() == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "expected_size[dimension] == tensor.size(dimension)",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(expected_size[dimension] == tensor.size(dimension)",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.hstack": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.index_select": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.masked_select": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.movedim": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.moveaxis": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.narrow": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "(self.dim() > 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "self.dim() > 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(start",
          "op": "<",
          "rhs": "0",
          "expr": "(start < 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "start",
          "op": "<",
          "rhs": "0",
          "expr": "start < 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(start < 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "start < 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nonzero": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.reshape": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.row_stack": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.vstack": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.scatter": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "slice.sizes()",
          "op": "==",
          "rhs": "src.sizes()",
          "expr": "slice.sizes() == src.sizes()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(slice.sizes()",
          "op": "==",
          "rhs": "src.sizes()",
          "expr": "(slice.sizes() == src.sizes()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "slice.sizes() == src.sizes()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(slice.sizes() == src.sizes()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.scatter_add": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(globalContext().deterministicAlgorithms() && self.device().type()",
          "op": "==",
          "rhs": "DeviceType::CUDA",
          "expr": "(globalContext().deterministicAlgorithms() && self.device().type() == DeviceType::CUDA",
          "negated": true,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "index.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "index.numel() == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(index.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "(index.numel() == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "globalContext().deterministicAlgorithms() && self.device().type()",
          "op": "==",
          "rhs": "DeviceType::CUDA",
          "expr": "globalContext().deterministicAlgorithms() && self.device().type() == DeviceType::CUDA",
          "negated": false,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "(can_use_expanded_index_path(mut_out, dim, index, src, /*is_scatter_like*/true)",
          "op": "",
          "rhs": "",
          "expr": "(can_use_expanded_index_path(mut_out, dim, index, src, /*is_scatter_like*/true)",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "can_use_expanded_index_path(mut_out, dim, index, src, /*is_scatter_like*/true)",
          "op": "",
          "rhs": "",
          "expr": "can_use_expanded_index_path(mut_out, dim, index, src, /*is_scatter_like*/true)",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(globalContext().deterministicAlgorithms() && self.device().type() == DeviceType::CUDA",
        "src": "cpp",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "index.numel() == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(index.numel() == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "globalContext().deterministicAlgorithms() && self.device().type() == DeviceType::CUDA",
        "src": "cpp",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "(can_use_expanded_index_path(mut_out, dim, index, src, /*is_scatter_like*/true)",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "can_use_expanded_index_path(mut_out, dim, index, src, /*is_scatter_like*/true)",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.split": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function_unary(tensor)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(tensor)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(tensor)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(tensor)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "(self.dim() > 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "self.dim() > 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function_unary(tensor)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(tensor)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.squeeze": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(dims",
          "op": "==",
          "rhs": "0 || self.sym_sizes()[dim] != 1",
          "expr": "(dims == 0 || self.sym_sizes()[dim] != 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dims",
          "op": "==",
          "rhs": "0 || self.sym_sizes()[dim] != 1",
          "expr": "dims == 0 || self.sym_sizes()[dim] != 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(dims == 0 || self.sym_sizes()[dim] != 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dims == 0 || self.sym_sizes()[dim] != 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.stack": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(tensor.dim()",
          "op": "<=",
          "rhs": "3",
          "expr": "(tensor.dim() <= 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dim",
          "op": ">=",
          "rhs": "-tensor.dim() - 1 && dim <= tensor.dim()",
          "expr": "dim >= -tensor.dim() - 1 && dim <= tensor.dim()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "tensor.dim()",
          "op": "<=",
          "rhs": "3",
          "expr": "tensor.dim() <= 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dim",
          "op": ">=",
          "rhs": "-tensor.dim() - 1 && dim <= tensor.dim()",
          "expr": "(dim >= -tensor.dim() - 1 && dim <= tensor.dim()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "!tensors.empty()",
          "op": "",
          "rhs": "",
          "expr": "!tensors.empty()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(wrapped_dim",
          "op": "<",
          "rhs": "tensors[0].ndimension() && !tensors[0].is_sparse()",
          "expr": "(wrapped_dim < tensors[0].ndimension() && !tensors[0].is_sparse()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(!tensors.empty()",
          "op": "",
          "rhs": "",
          "expr": "(!tensors.empty()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "wrapped_dim",
          "op": "<",
          "rhs": "tensors[0].ndimension() && !tensors[0].is_sparse()",
          "expr": "wrapped_dim < tensors[0].ndimension() && !tensors[0].is_sparse()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(tensor.dim() <= 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dim >= -tensor.dim() - 1 && dim <= tensor.dim()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "tensor.dim() <= 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(dim >= -tensor.dim() - 1 && dim <= tensor.dim()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "!tensors.empty()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(wrapped_dim < tensors[0].ndimension() && !tensors[0].is_sparse()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(!tensors.empty()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "wrapped_dim < tensors[0].ndimension() && !tensors[0].is_sparse()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.swapaxes": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.transpose": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.swapdims": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.t": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.take": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tensor_split": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "(self.dim() > 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "self.dim()",
          "op": ">",
          "rhs": "0",
          "expr": "self.dim() > 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "self.dim() > 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.tile": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.unbind": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.unsqueeze": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "dim",
          "op": "==",
          "rhs": "0",
          "expr": "dim == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "self.dim()",
          "op": "<",
          "rhs": "3",
          "expr": "self.dim() < 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.dim()",
          "op": "<",
          "rhs": "3",
          "expr": "(self.dim() < 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dim",
          "op": "<",
          "rhs": "0",
          "expr": "(dim < 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dim",
          "op": ">=",
          "rhs": "-self.dim() - 1 && dim <= self.dim()",
          "expr": "(dim >= -self.dim() - 1 && dim <= self.dim()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dim",
          "op": "==",
          "rhs": "0",
          "expr": "(dim == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dim",
          "op": ">=",
          "rhs": "-self.dim() - 1 && dim <= self.dim()",
          "expr": "dim >= -self.dim() - 1 && dim <= self.dim()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dim",
          "op": "<",
          "rhs": "0",
          "expr": "dim < 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.dim()",
          "op": "<=",
          "rhs": "3",
          "expr": "(self.dim() <= 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "self.dim()",
          "op": "<=",
          "rhs": "3",
          "expr": "self.dim() <= 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "dim == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.dim() < 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(self.dim() < 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dim < 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dim >= -self.dim() - 1 && dim <= self.dim()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dim == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dim >= -self.dim() - 1 && dim <= self.dim()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "dim < 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(self.dim() <= 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "self.dim() <= 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.where": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.Generator": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.seed": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not torch.xpu._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "(not torch.xpu._is_in_bad_fork()",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not torch.xpu._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "not torch.xpu._is_in_bad_fork()",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not torch.cuda._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "not torch.cuda._is_in_bad_fork()",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(not torch.mps._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "(not torch.mps._is_in_bad_fork()",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(not torch.cuda._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "(not torch.cuda._is_in_bad_fork()",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not torch.mps._is_in_bad_fork()",
          "op": "",
          "rhs": "",
          "expr": "not torch.mps._is_in_bad_fork()",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(not torch.xpu._is_in_bad_fork()",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "not torch.xpu._is_in_bad_fork()",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "not torch.cuda._is_in_bad_fork()",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(not torch.mps._is_in_bad_fork()",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "(not torch.cuda._is_in_bad_fork()",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "not torch.mps._is_in_bad_fork()",
        "src": "python",
        "type": "logical_check",
        "negated": false
      }
    ]
  },
  "torch.manual_seed": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.initial_seed": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.get_rng_state": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_rng_state": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bernoulli": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.multinomial": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.normal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.poisson": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.quasirandom.SobolEngine": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.save": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(_use_new_zipfile_serialization",
          "op": "",
          "rhs": "",
          "expr": "(_use_new_zipfile_serialization",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "_use_new_zipfile_serialization",
          "op": "",
          "rhs": "",
          "expr": "_use_new_zipfile_serialization",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(_use_new_zipfile_serialization",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "_use_new_zipfile_serialization",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.load": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(pickle_module",
          "op": "is",
          "rhs": "None",
          "expr": "(pickle_module is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "'encoding'",
          "op": "not in",
          "rhs": "pickle_load_args.keys()",
          "expr": "'encoding' not in pickle_load_args.keys()",
          "negated": false,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "mmap",
          "op": "",
          "rhs": "",
          "expr": "mmap",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(weights_only",
          "op": "is",
          "rhs": "None",
          "expr": "(weights_only is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(_is_zipfile(opened_file)",
          "op": "",
          "rhs": "",
          "expr": "(_is_zipfile(opened_file)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(warn_weights_only",
          "op": "",
          "rhs": "",
          "expr": "(warn_weights_only",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "_is_torchscript_zip(opened_zipfile)",
          "op": "",
          "rhs": "",
          "expr": "_is_torchscript_zip(opened_zipfile)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_unsafe_global",
          "op": "",
          "rhs": "",
          "expr": "has_unsafe_global",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(has_unsafe_global",
          "op": "",
          "rhs": "",
          "expr": "(has_unsafe_global",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "pickle_module",
          "op": "is",
          "rhs": "None",
          "expr": "pickle_module is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(mmap",
          "op": "",
          "rhs": "",
          "expr": "(mmap",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(mmap",
          "op": "is",
          "rhs": "None",
          "expr": "(mmap is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(weights_only",
          "op": "",
          "rhs": "",
          "expr": "(weights_only",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(_is_torchscript_zip(opened_zipfile)",
          "op": "",
          "rhs": "",
          "expr": "(_is_torchscript_zip(opened_zipfile)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "_is_zipfile(opened_file)",
          "op": "",
          "rhs": "",
          "expr": "_is_zipfile(opened_file)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weights_only",
          "op": "is",
          "rhs": "None",
          "expr": "weights_only is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(pickle_module",
          "op": "is",
          "rhs": "not None",
          "expr": "(pickle_module is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mmap",
          "op": "is",
          "rhs": "None",
          "expr": "mmap is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(not _is_path(f)",
          "op": "",
          "rhs": "",
          "expr": "(not _is_path(f)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "warn_weights_only",
          "op": "",
          "rhs": "",
          "expr": "warn_weights_only",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weights_only",
          "op": "",
          "rhs": "",
          "expr": "weights_only",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "('encoding'",
          "op": "not in",
          "rhs": "pickle_load_args.keys()",
          "expr": "('encoding' not in pickle_load_args.keys()",
          "negated": true,
          "type": "membership_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(pickle_module is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "'encoding' not in pickle_load_args.keys()",
        "src": "python",
        "type": "membership_check",
        "negated": false
      },
      {
        "expr": "mmap",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(weights_only is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(_is_zipfile(opened_file)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(warn_weights_only",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "_is_torchscript_zip(opened_zipfile)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "has_unsafe_global",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(has_unsafe_global",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "pickle_module is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(mmap",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(mmap is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(weights_only",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(_is_torchscript_zip(opened_zipfile)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "_is_zipfile(opened_file)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "weights_only is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(pickle_module is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "mmap is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(not _is_path(f)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "warn_weights_only",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "weights_only",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "('encoding' not in pickle_load_args.keys()",
        "src": "python",
        "type": "membership_check",
        "negated": true
      }
    ]
  },
  "torch.get_num_threads": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_num_threads": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.get_num_interop_threads": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_num_interop_threads": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.set_grad_enabled": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.abs": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.absolute": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.acos": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arccos": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.acosh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arccosh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.add": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self.is_sparse() && !other.is_sparse()",
          "op": "",
          "rhs": "",
          "expr": "(self.is_sparse() && !other.is_sparse()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "self.is_sparse() && !other.is_sparse()",
          "op": "",
          "rhs": "",
          "expr": "self.is_sparse() && !other.is_sparse()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self.is_sparse() && !other.is_sparse()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "self.is_sparse() && !other.is_sparse()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      }
    ]
  },
  "torch.addcdiv": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.addcmul": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.asin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arcsin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.asinh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arcsinh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atan": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arctan": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atanh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.arctanh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atan2": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bitwise_not": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bitwise_and": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bitwise_or": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bitwise_xor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ceil": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.clamp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.max": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!is_symbolic() && !sci.is_symbolic()",
          "op": "",
          "rhs": "",
          "expr": "!is_symbolic() && !sci.is_symbolic()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.numel()",
          "op": ">",
          "rhs": "0",
          "expr": "(self.numel() > 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self.numel()",
          "op": ">",
          "rhs": "0",
          "expr": "self.numel() > 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(",
          "op": "<",
          "rhs": "empty>",
          "expr": "(<empty>",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(!is_symbolic() && !sci.is_symbolic()",
          "op": "",
          "rhs": "",
          "expr": "(!is_symbolic() && !sci.is_symbolic()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "",
          "op": "<",
          "rhs": "empty>",
          "expr": "<empty>",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!is_symbolic() && !sci.is_symbolic()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(self.numel() > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self.numel() > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(<empty>",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(!is_symbolic() && !sci.is_symbolic()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "<empty>",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.clip": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.conj": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.copysign": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cos": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cosh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.deg2rad": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.div": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "c10::isIntegralType(commonDtype, /*includeBool=*/true) && !rounding_mode.has_value()",
          "op": "",
          "rhs": "",
          "expr": "c10::isIntegralType(commonDtype, /*includeBool=*/true) && !rounding_mode.has_value()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "(c10::isIntegralType(commonDtype, /*includeBool=*/true) && !rounding_mode.has_value()",
          "op": "",
          "rhs": "",
          "expr": "(c10::isIntegralType(commonDtype, /*includeBool=*/true) && !rounding_mode.has_value()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "c10::isIntegralType(commonDtype, /*includeBool=*/true) && !rounding_mode.has_value()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(c10::isIntegralType(commonDtype, /*includeBool=*/true) && !rounding_mode.has_value()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      }
    ]
  },
  "torch.divide": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.digamma": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.erf": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.erfc": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.erfinv": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.exp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.exp2": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.expm1": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.fake_quantize_per_channel_affine": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.fake_quantize_per_tensor_affine": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.fix": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.trunc": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.float_power": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.floor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.floor_divide": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.fmod": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.frac": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ldexp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lerp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lgamma": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.log": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.log10": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.log1p": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.log2": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logaddexp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logaddexp2": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logical_and": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logical_not": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logical_or": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logical_xor": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logit": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.hypot": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.i0": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.igamma": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.igammac": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.mul": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.multiply": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.mvlgamma": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(at::isIntegralType(self.scalar_type(), /*include_bool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "(at::isIntegralType(self.scalar_type(), /*include_bool=*/true)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "at::isIntegralType(self.scalar_type(), /*include_bool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "at::isIntegralType(self.scalar_type(), /*include_bool=*/true)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(at::isIntegralType(self.scalar_type(), /*include_bool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "at::isIntegralType(self.scalar_type(), /*include_bool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nan_to_num": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.neg": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.negative": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nextafter": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.polygamma": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.pow": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.rad2deg": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.real": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.reciprocal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.remainder": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.round": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.rsqrt": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sigmoid": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sign": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sgn": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.signbit": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sinc": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sinh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sqrt": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.square": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sub": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.subtract": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tan": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tanh": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.true_divide": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.xlogy": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.argmax": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.argmin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.amax": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.amin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.all": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.any": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.min": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "!is_symbolic() && !sci.is_symbolic()",
          "op": "",
          "rhs": "",
          "expr": "!is_symbolic() && !sci.is_symbolic()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.numel()",
          "op": ">",
          "rhs": "0",
          "expr": "(self.numel() > 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self.numel()",
          "op": ">",
          "rhs": "0",
          "expr": "self.numel() > 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(",
          "op": "<",
          "rhs": "empty>",
          "expr": "(<empty>",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(!is_symbolic() && !sci.is_symbolic()",
          "op": "",
          "rhs": "",
          "expr": "(!is_symbolic() && !sci.is_symbolic()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "",
          "op": "<",
          "rhs": "empty>",
          "expr": "<empty>",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "!is_symbolic() && !sci.is_symbolic()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(self.numel() > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self.numel() > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(<empty>",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(!is_symbolic() && !sci.is_symbolic()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "<empty>",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.dist": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logsumexp": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "at::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "at::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(at::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "(at::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "at::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(at::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.mean": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.median": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nanmedian": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.mode": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.layout",
          "op": "==",
          "rhs": "torch.strided && input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
          "expr": "input.layout == torch.strided && input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
          "negated": false,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(p, str)",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(p, str)",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "_dim",
          "op": "is",
          "rhs": "None",
          "expr": "_dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "==",
          "rhs": "'fro'",
          "expr": "p == 'fro'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "==",
          "rhs": "'fro' && (dim is None || isinstance(dim, (int, torch.SymInt)) || len(dim) <= 2)",
          "expr": "p == 'fro' && (dim is None || isinstance(dim, (int, torch.SymInt)) || len(dim) <= 2)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "not None",
          "expr": "dim is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(dim, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(dim, (int, torch.SymInt))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(dim",
          "op": "is",
          "rhs": "None && out is None && (dtype is None) && (p is not None)",
          "expr": "(dim is None && out is None && (dtype is None) && (p is not None)",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(dim, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dim, (int, torch.SymInt))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(not isinstance(p, str)",
          "op": "",
          "rhs": "",
          "expr": "(not isinstance(p, str)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "==",
          "rhs": "'nuc'",
          "expr": "p == 'nuc'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(_dim",
          "op": "is",
          "rhs": "None",
          "expr": "(_dim is None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(dtype",
          "op": "is",
          "rhs": "None",
          "expr": "(dtype is None",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "(dim",
          "op": "is",
          "rhs": "not None",
          "expr": "(dim is not None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(p",
          "op": "==",
          "rhs": "'fro'",
          "expr": "(p == 'fro'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(p",
          "op": "==",
          "rhs": "'nuc'",
          "expr": "(p == 'nuc'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(dtype",
          "op": "is",
          "rhs": "not None",
          "expr": "(dtype is not None",
          "negated": true,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None && out is None && (dtype is None) && (p is not None)",
          "expr": "dim is None && out is None && (dtype is None) && (p is not None)",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(p, str)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(p, str)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(isinstance(p, str)",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(p, str)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(p",
          "op": "==",
          "rhs": "'fro' && (dim is None || isinstance(dim, (int, torch.SymInt)) || len(dim) <= 2)",
          "expr": "(p == 'fro' && (dim is None || isinstance(dim, (int, torch.SymInt)) || len(dim) <= 2)",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(input.layout",
          "op": "==",
          "rhs": "torch.strided && input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
          "expr": "(input.layout == torch.strided && input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
          "negated": true,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "(out",
          "op": "is",
          "rhs": "None",
          "expr": "(out is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.layout == torch.strided && input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "not isinstance(p, str)",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "_dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "p == 'fro'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "p == 'fro' && (dim is None || isinstance(dim, (int, torch.SymInt)) || len(dim) <= 2)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "dim is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(isinstance(dim, (int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dim is None && out is None && (dtype is None) && (p is not None)",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "isinstance(dim, (int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(not isinstance(p, str)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "p == 'nuc'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(_dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(dim is not None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(p == 'fro'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(p == 'nuc'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(dtype is not None",
        "src": "python",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "dim is None && out is None && (dtype is None) && (p is not None)",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "isinstance(p, str)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(isinstance(p, str)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(p == 'fro' && (dim is None || isinstance(dim, (int, torch.SymInt)) || len(dim) <= 2)",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(input.layout == torch.strided && input.device.type in ('cpu', 'cuda', 'meta', torch.utils.backend_registration._privateuse1_backend_name)",
        "src": "python",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "(out is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      }
    ]
  },
  "torch.nansum": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.prod": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.quantile": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nanquantile": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.std": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.std_mean": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sum": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "k",
          "op": "<",
          "rhs": "ilp_factor",
          "expr": "k < ilp_factor",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(k",
          "op": "<",
          "rhs": "ilp_factor",
          "expr": "(k < ilp_factor",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.size(d)",
          "op": "==",
          "rhs": "0",
          "expr": "(self.size(d) == 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "i",
          "op": "<",
          "rhs": "N",
          "expr": "i < N",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(d",
          "op": "<",
          "rhs": "self.dim()",
          "expr": "(d < self.dim()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(i",
          "op": "<",
          "rhs": "N",
          "expr": "(i < N",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "i + ilp_factor",
          "op": "<=",
          "rhs": "N",
          "expr": "i + ilp_factor <= N",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "d",
          "op": "<",
          "rhs": "self.dim()",
          "expr": "d < self.dim()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(i + ilp_factor",
          "op": "<=",
          "rhs": "N",
          "expr": "(i + ilp_factor <= N",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self.size(d)",
          "op": "==",
          "rhs": "0",
          "expr": "self.size(d) == 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "k < ilp_factor",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(k < ilp_factor",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(self.size(d) == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "i < N",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(d < self.dim()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(i < N",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "i + ilp_factor <= N",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "d < self.dim()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(i + ilp_factor <= N",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self.size(d) == 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.unique": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "self.scalar_type()",
          "op": "==",
          "rhs": "kBool",
          "expr": "self.scalar_type() == kBool",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.scalar_type()",
          "op": "==",
          "rhs": "kBool",
          "expr": "(self.scalar_type() == kBool",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.scalar_type() == kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(self.scalar_type() == kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.unique_consecutive": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(!dim.has_value() || (dim.value()",
          "op": "==",
          "rhs": "0 && self.dim() == 1)",
          "expr": "(!dim.has_value() || (dim.value() == 0 && self.dim() == 1)",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "!dim.has_value() || (dim.value()",
          "op": "==",
          "rhs": "0 && self.dim() == 1)",
          "expr": "!dim.has_value() || (dim.value() == 0 && self.dim() == 1)",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(!dim.has_value() || (dim.value() == 0 && self.dim() == 1)",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "!dim.has_value() || (dim.value() == 0 && self.dim() == 1)",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.var": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.var_mean": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.count_nonzero": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(dim",
          "op": "",
          "rhs": "",
          "expr": "(dim",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dim",
          "op": "",
          "rhs": "",
          "expr": "dim",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(dim",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dim",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.allclose": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.argsort": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.eq": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.equal": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "self.device()",
          "op": "==",
          "rhs": "other.device()",
          "expr": "self.device() == other.device()",
          "negated": false,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "(!self.is_same_size(other)",
          "op": "",
          "rhs": "",
          "expr": "(!self.is_same_size(other)",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "!self.is_same_size(other)",
          "op": "",
          "rhs": "",
          "expr": "!self.is_same_size(other)",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(self.device()",
          "op": "==",
          "rhs": "other.device()",
          "expr": "(self.device() == other.device()",
          "negated": true,
          "type": "device_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "self.device() == other.device()",
        "src": "cpp",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "(!self.is_same_size(other)",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "!self.is_same_size(other)",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(self.device() == other.device()",
        "src": "cpp",
        "type": "device_check",
        "negated": true
      }
    ]
  },
  "torch.ge": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.greater_equal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.gt": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.greater": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.isclose": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.isfinite": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.isinf": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "op": "",
          "rhs": "",
          "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(c10::isIntegralType(self.scalar_type(), /*includeBool=*/true)",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.isposinf": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.isneginf": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.isnan": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.isreal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.kthvalue": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.le": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.less_equal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lt": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.less": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.maximum": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.minimum": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.fmax": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.fmin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ne": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.not_equal": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.sort": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(dtype().is_floating_point()",
          "op": "",
          "rhs": "",
          "expr": "(dtype().is_floating_point()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "dtype().is_floating_point()",
          "op": "",
          "rhs": "",
          "expr": "dtype().is_floating_point()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(dtype().is_floating_point()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "dtype().is_floating_point()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.topk": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.msort": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.stft": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_unary(input)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(center",
          "op": "",
          "rhs": "",
          "expr": "(center",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "center",
          "op": "",
          "rhs": "",
          "expr": "center",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(center",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "center",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.istft": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bartlett_window": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "0",
          "expr": "(window_length == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "0",
          "expr": "window_length == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "1",
          "expr": "window_length == 1",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(periodic",
          "op": "",
          "rhs": "",
          "expr": "(periodic",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "periodic",
          "op": "",
          "rhs": "",
          "expr": "periodic",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "1",
          "expr": "(window_length == 1",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.blackman_window": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "0",
          "expr": "(window_length == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "0",
          "expr": "window_length == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "1",
          "expr": "window_length == 1",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(periodic",
          "op": "",
          "rhs": "",
          "expr": "(periodic",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "periodic",
          "op": "",
          "rhs": "",
          "expr": "periodic",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "1",
          "expr": "(window_length == 1",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.hamming_window": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "0",
          "expr": "(window_length == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "0",
          "expr": "window_length == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "1",
          "expr": "window_length == 1",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(periodic",
          "op": "",
          "rhs": "",
          "expr": "(periodic",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "periodic",
          "op": "",
          "rhs": "",
          "expr": "periodic",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "1",
          "expr": "(window_length == 1",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.hann_window": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.kaiser_window": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "0",
          "expr": "(window_length == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(device",
          "op": "==",
          "rhs": "kMeta",
          "expr": "(device == kMeta",
          "negated": true,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "0",
          "expr": "window_length == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "window_length",
          "op": "==",
          "rhs": "1",
          "expr": "window_length == 1",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(periodic",
          "op": "",
          "rhs": "",
          "expr": "(periodic",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "periodic",
          "op": "",
          "rhs": "",
          "expr": "periodic",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "device",
          "op": "==",
          "rhs": "kMeta",
          "expr": "device == kMeta",
          "negated": false,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "(window_length",
          "op": "==",
          "rhs": "1",
          "expr": "(window_length == 1",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(device == kMeta",
        "src": "cpp",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "window_length == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "periodic",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "device == kMeta",
        "src": "cpp",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "(window_length == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.atleast_1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atleast_2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.atleast_3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bincount": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.block_diag": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(tensor.device()",
          "op": "==",
          "rhs": "device",
          "expr": "(tensor.device() == device",
          "negated": true,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "tensor.device()",
          "op": "==",
          "rhs": "device",
          "expr": "tensor.device() == device",
          "negated": false,
          "type": "device_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(tensor.device() == device",
        "src": "cpp",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "tensor.device() == device",
        "src": "cpp",
        "type": "device_check",
        "negated": false
      }
    ]
  },
  "torch.broadcast_tensors": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.broadcast_to": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.broadcast_shapes": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(shape, (tuple, list))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(shape, (tuple, list))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(shape, (tuple, list))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(shape, (tuple, list))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(shape, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(shape, (int, torch.SymInt))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "guard_size_oblivious(shape[i]",
          "op": "==",
          "rhs": "1) || guard_size_oblivious(shape[i] == result[i])",
          "expr": "guard_size_oblivious(shape[i] == 1) || guard_size_oblivious(shape[i] == result[i])",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(guard_size_oblivious(shape[i]",
          "op": "==",
          "rhs": "1) || guard_size_oblivious(shape[i] == result[i])",
          "expr": "(guard_size_oblivious(shape[i] == 1) || guard_size_oblivious(shape[i] == result[i])",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(shape, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(shape, (int, torch.SymInt))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(shape[i]",
          "op": "<",
          "rhs": "0",
          "expr": "(shape[i] < 0",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(shape, (tuple, list))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(isinstance(shape, (tuple, list))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(isinstance(shape, (int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "guard_size_oblivious(shape[i] == 1) || guard_size_oblivious(shape[i] == result[i])",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(guard_size_oblivious(shape[i] == 1) || guard_size_oblivious(shape[i] == result[i])",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "isinstance(shape, (int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(shape[i] < 0",
        "src": "python",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.bucketize": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cartesian_prod": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cdist": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "compute_mode",
          "op": "==",
          "rhs": "'use_mm_for_euclid_dist_if_necessary'",
          "expr": "compute_mode == 'use_mm_for_euclid_dist_if_necessary'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(compute_mode",
          "op": "==",
          "rhs": "'use_mm_for_euclid_dist_if_necessary'",
          "expr": "(compute_mode == 'use_mm_for_euclid_dist_if_necessary'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(x1, x2)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(x1, x2)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "compute_mode",
          "op": "==",
          "rhs": "'use_mm_for_euclid_dist'",
          "expr": "compute_mode == 'use_mm_for_euclid_dist'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(compute_mode",
          "op": "==",
          "rhs": "'use_mm_for_euclid_dist'",
          "expr": "(compute_mode == 'use_mm_for_euclid_dist'",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "compute_mode",
          "op": "==",
          "rhs": "'donot_use_mm_for_euclid_dist'",
          "expr": "compute_mode == 'donot_use_mm_for_euclid_dist'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(x1, x2)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(x1, x2)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "compute_mode == 'use_mm_for_euclid_dist_if_necessary'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(compute_mode == 'use_mm_for_euclid_dist_if_necessary'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(has_torch_function_variadic(x1, x2)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "compute_mode == 'use_mm_for_euclid_dist'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(compute_mode == 'use_mm_for_euclid_dist'",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "compute_mode == 'donot_use_mm_for_euclid_dist'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(x1, x2)",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.clone": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(memory_format",
          "op": "==",
          "rhs": "MemoryFormat::Preserve",
          "expr": "(memory_format == MemoryFormat::Preserve",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "memory_format",
          "op": "==",
          "rhs": "MemoryFormat::Preserve",
          "expr": "memory_format == MemoryFormat::Preserve",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(memory_format == MemoryFormat::Preserve",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "memory_format == MemoryFormat::Preserve",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.combinations": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cross": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cummax": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cummin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cumprod": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cumsum": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.diag": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(tensor.device()",
          "op": "==",
          "rhs": "device",
          "expr": "(tensor.device() == device",
          "negated": true,
          "type": "device_check",
          "src": "cpp"
        },
        {
          "lhs": "tensor.device()",
          "op": "==",
          "rhs": "device",
          "expr": "tensor.device() == device",
          "negated": false,
          "type": "device_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(tensor.device() == device",
        "src": "cpp",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "tensor.device() == device",
        "src": "cpp",
        "type": "device_check",
        "negated": false
      }
    ]
  },
  "torch.diag_embed": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(dim1",
          "op": "!=",
          "rhs": "dim2",
          "expr": "(dim1 != dim2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dim1",
          "op": "!=",
          "rhs": "dim2",
          "expr": "dim1 != dim2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(dim1 != dim2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dim1 != dim2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.diagflat": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.diagonal": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(offset",
          "op": ">=",
          "rhs": "0",
          "expr": "(offset >= 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(dim1",
          "op": "!=",
          "rhs": "dim2",
          "expr": "(dim1 != dim2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dim1",
          "op": "!=",
          "rhs": "dim2",
          "expr": "dim1 != dim2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "offset",
          "op": ">=",
          "rhs": "0",
          "expr": "offset >= 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(offset >= 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(dim1 != dim2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dim1 != dim2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "offset >= 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.diff": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.einsum": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "len(operands)",
          "op": "<=",
          "rhs": "2 || not opt_einsum.enabled",
          "expr": "len(operands) <= 2 || not opt_einsum.enabled",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function(operands)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function(operands)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(len(operands)",
          "op": "<=",
          "rhs": "2 || not opt_einsum.enabled",
          "expr": "(len(operands) <= 2 || not opt_einsum.enabled",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function(operands)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function(operands)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "len(operands)",
          "op": "==",
          "rhs": "1 && isinstance(operands[0], (list, tuple))",
          "expr": "len(operands) == 1 && isinstance(operands[0], (list, tuple))",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(len(operands)",
          "op": "==",
          "rhs": "1 && isinstance(operands[0], (list, tuple))",
          "expr": "(len(operands) == 1 && isinstance(operands[0], (list, tuple))",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "len(operands) <= 2 || not opt_einsum.enabled",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function(operands)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(len(operands) <= 2 || not opt_einsum.enabled",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "has_torch_function(operands)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "len(operands) == 1 && isinstance(operands[0], (list, tuple))",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(len(operands) == 1 && isinstance(operands[0], (list, tuple))",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.flatten": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.flip": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(flip_dims_b[i] && self.size(i)",
          "op": ">",
          "rhs": "1 && self.stride(i) != 0",
          "expr": "(flip_dims_b[i] && self.size(i) > 1 && self.stride(i) != 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "flip_dims_b[i] && self.size(i)",
          "op": ">",
          "rhs": "1 && self.stride(i) != 0",
          "expr": "flip_dims_b[i] && self.size(i) > 1 && self.stride(i) != 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(flip_dims_b[i] && self.size(i) > 1 && self.stride(i) != 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "flip_dims_b[i] && self.size(i) > 1 && self.stride(i) != 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.fliplr": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.flipud": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.kron": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.rot90": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "total_rot_dims",
          "op": "==",
          "rhs": "2",
          "expr": "total_rot_dims == 2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "k",
          "op": "==",
          "rhs": "3",
          "expr": "k == 3",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "dims[0]",
          "op": "!=",
          "rhs": "dims[1] && std::abs(dims[0] - dims[1]) != total_dims",
          "expr": "dims[0] != dims[1] && std::abs(dims[0] - dims[1]) != total_dims",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(total_rot_dims",
          "op": "==",
          "rhs": "2",
          "expr": "(total_rot_dims == 2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dims[0]",
          "op": "!=",
          "rhs": "dims[1] && std::abs(dims[0] - dims[1]) != total_dims",
          "expr": "(dims[0] != dims[1] && std::abs(dims[0] - dims[1]) != total_dims",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "k",
          "op": "==",
          "rhs": "2",
          "expr": "k == 2",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "k other",
          "op": "",
          "rhs": "",
          "expr": "k other",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "dims[0]",
          "op": "<",
          "rhs": "total_dims && dims[0] >= -total_dims",
          "expr": "dims[0] < total_dims && dims[0] >= -total_dims",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "k",
          "op": "==",
          "rhs": "1",
          "expr": "k == 1",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "total_dims",
          "op": ">=",
          "rhs": "2",
          "expr": "total_dims >= 2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dims[1]",
          "op": "<",
          "rhs": "total_dims && dims[1] >= -total_dims",
          "expr": "dims[1] < total_dims && dims[1] >= -total_dims",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dims[1]",
          "op": "<",
          "rhs": "total_dims && dims[1] >= -total_dims",
          "expr": "(dims[1] < total_dims && dims[1] >= -total_dims",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(total_dims",
          "op": ">=",
          "rhs": "2",
          "expr": "(total_dims >= 2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(dims[0]",
          "op": "<",
          "rhs": "total_dims && dims[0] >= -total_dims",
          "expr": "(dims[0] < total_dims && dims[0] >= -total_dims",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "total_rot_dims == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "k == 3",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "dims[0] != dims[1] && std::abs(dims[0] - dims[1]) != total_dims",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(total_rot_dims == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dims[0] != dims[1] && std::abs(dims[0] - dims[1]) != total_dims",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "k == 2",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "k other",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "dims[0] < total_dims && dims[0] >= -total_dims",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "k == 1",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "total_dims >= 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "dims[1] < total_dims && dims[1] >= -total_dims",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(dims[1] < total_dims && dims[1] >= -total_dims",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(total_dims >= 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dims[0] < total_dims && dims[0] >= -total_dims",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.gcd": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.histc": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.meshgrid": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lcm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.logcumsumexp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ravel": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.renorm": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "acc_type",
          "op": "!=",
          "rhs": "dtype",
          "expr": "acc_type != dtype",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(acc_type",
          "op": "!=",
          "rhs": "dtype",
          "expr": "(acc_type != dtype",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "acc_type != dtype",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "(acc_type != dtype",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      }
    ]
  },
  "torch.repeat_interleave": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.roll": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(dims.size()",
          "op": "!=",
          "rhs": "1 || shifts.size() != 1",
          "expr": "(dims.size() != 1 || shifts.size() != 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "dims.size()",
          "op": "!=",
          "rhs": "1 || shifts.size() != 1",
          "expr": "dims.size() != 1 || shifts.size() != 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(dims.size() != 1 || shifts.size() != 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dims.size() != 1 || shifts.size() != 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.searchsorted": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tensordot": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(dims, (tuple, list))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dims, (tuple, list))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "(not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(dims, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dims, torch.Tensor)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(dims, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(dims, torch.Tensor)",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(out",
          "op": "is",
          "rhs": "None",
          "expr": "(out is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "dims.size()[0]",
          "op": "==",
          "rhs": "2",
          "expr": "dims.size()[0] == 2",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(dims, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(dims, (int, torch.SymInt))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(a, b)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(a, b)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(isinstance(dims, (tuple, list))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(dims, (tuple, list))",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(dims",
          "op": "<",
          "rhs": "0",
          "expr": "(dims < 0",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(has_torch_function_variadic(a, b)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function_variadic(a, b)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(dims_val",
          "op": "<",
          "rhs": "0",
          "expr": "(dims_val < 0",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(dims",
          "op": ">",
          "rhs": "min(a.dim(), b.dim())",
          "expr": "(dims > min(a.dim(), b.dim())",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(dims, (int, torch.SymInt))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(dims, (int, torch.SymInt))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(dims, (tuple, list))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "isinstance(dims, torch.Tensor)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(isinstance(dims, torch.Tensor)",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(out is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "dims.size()[0] == 2",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(isinstance(dims, (int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "has_torch_function_variadic(a, b)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(isinstance(dims, (tuple, list))",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dims < 0",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(has_torch_function_variadic(a, b)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(dims_val < 0",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(dims > min(a.dim(), b.dim())",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "isinstance(dims, (int, torch.SymInt))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.trace": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tril": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.tril_indices": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(!dtype_opt.has_value()",
          "op": "",
          "rhs": "",
          "expr": "(!dtype_opt.has_value()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "!dtype_opt.has_value()",
          "op": "",
          "rhs": "",
          "expr": "!dtype_opt.has_value()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(!dtype_opt.has_value()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "!dtype_opt.has_value()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.triu": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.triu_indices": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(!dtype_opt.has_value()",
          "op": "",
          "rhs": "",
          "expr": "(!dtype_opt.has_value()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "!dtype_opt.has_value()",
          "op": "",
          "rhs": "",
          "expr": "!dtype_opt.has_value()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(!dtype_opt.has_value()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "!dtype_opt.has_value()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.vander": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.view_as_real": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.view_as_complex": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.addbmm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.addmm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.addmv": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(use_mkldnn_matmul(mat, vec, /*result=*/Tensor())",
          "op": "",
          "rhs": "",
          "expr": "(use_mkldnn_matmul(mat, vec, /*result=*/Tensor())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "use_mkldnn_matmul(mat, vec, /*result=*/Tensor())",
          "op": "",
          "rhs": "",
          "expr": "use_mkldnn_matmul(mat, vec, /*result=*/Tensor())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "!result.is_same(*self_) && betaval",
          "op": "!=",
          "rhs": "0.0",
          "expr": "!result.is_same(*self_) && betaval != 0.0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(mat.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "(mat.numel() == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(betaval",
          "op": "==",
          "rhs": "0.0",
          "expr": "(betaval == 0.0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "betaval",
          "op": "==",
          "rhs": "0.0",
          "expr": "betaval == 0.0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "mat.numel()",
          "op": "==",
          "rhs": "0",
          "expr": "mat.numel() == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(!result.is_same(*self_) && betaval",
          "op": "!=",
          "rhs": "0.0",
          "expr": "(!result.is_same(*self_) && betaval != 0.0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(use_mkldnn_matmul(mat, vec, /*result=*/Tensor())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "use_mkldnn_matmul(mat, vec, /*result=*/Tensor())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "!result.is_same(*self_) && betaval != 0.0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(mat.numel() == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(betaval == 0.0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "betaval == 0.0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "mat.numel() == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(!result.is_same(*self_) && betaval != 0.0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.addr": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.baddbmm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.bmm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.chain_matmul": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(has_torch_function(matrices)",
          "op": "",
          "rhs": "",
          "expr": "(has_torch_function(matrices)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "has_torch_function(matrices)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function(matrices)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(out",
          "op": "is",
          "rhs": "None",
          "expr": "(out is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "out",
          "op": "is",
          "rhs": "None",
          "expr": "out is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(has_torch_function(matrices)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "has_torch_function(matrices)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(out is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "out is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.cholesky": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "upper",
          "op": "",
          "rhs": "",
          "expr": "upper",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(upper",
          "op": "",
          "rhs": "",
          "expr": "(upper",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "upper",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(upper",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.cholesky_inverse": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.cholesky_solve": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.dot": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "other.is_conj()",
          "op": "",
          "rhs": "",
          "expr": "other.is_conj()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(self._is_zerotensor() || other._is_zerotensor()",
          "op": "",
          "rhs": "",
          "expr": "(self._is_zerotensor() || other._is_zerotensor()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "(other.is_conj()",
          "op": "",
          "rhs": "",
          "expr": "(other.is_conj()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(use_mkldnn_matmul(self, other, /*result=*/Tensor())",
          "op": "",
          "rhs": "",
          "expr": "(use_mkldnn_matmul(self, other, /*result=*/Tensor())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "use_mkldnn_matmul(self, other, /*result=*/Tensor())",
          "op": "",
          "rhs": "",
          "expr": "use_mkldnn_matmul(self, other, /*result=*/Tensor())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "self._is_zerotensor() || other._is_zerotensor()",
          "op": "",
          "rhs": "",
          "expr": "self._is_zerotensor() || other._is_zerotensor()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "other.is_conj()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(self._is_zerotensor() || other._is_zerotensor()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "(other.is_conj()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(use_mkldnn_matmul(self, other, /*result=*/Tensor())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "use_mkldnn_matmul(self, other, /*result=*/Tensor())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "self._is_zerotensor() || other._is_zerotensor()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      }
    ]
  },
  "torch.geqrf": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ger": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.outer": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.inner": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.inverse": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.det": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "THPVariable_Check(out.ptr())",
          "op": "",
          "rhs": "",
          "expr": "THPVariable_Check(out.ptr())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(THPVariable_Check(out.ptr())",
          "op": "",
          "rhs": "",
          "expr": "(THPVariable_Check(out.ptr())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "THPVariable_Check(out.ptr())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(THPVariable_Check(out.ptr())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.logdet": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.slogdet": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lu": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lu_solve": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.lu_unpack": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(unpack_pivots",
          "op": "",
          "rhs": "",
          "expr": "(unpack_pivots",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "unpack_pivots",
          "op": "",
          "rhs": "",
          "expr": "unpack_pivots",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(unpack_pivots",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "unpack_pivots",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.matmul": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.matrix_power": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.matrix_exp": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.mm": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "mat1.is_sparse() && mat2.is_sparse()",
          "op": "",
          "rhs": "",
          "expr": "mat1.is_sparse() && mat2.is_sparse()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "(mat1.is_sparse() && mat2.is_sparse()",
          "op": "",
          "rhs": "",
          "expr": "(mat1.is_sparse() && mat2.is_sparse()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "mat1.is_sparse() && mat2.is_sparse()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(mat1.is_sparse() && mat2.is_sparse()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      }
    ]
  },
  "torch.mv": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.orgqr": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.ormqr": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.pinverse": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.qr": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.svd": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.svd_lowrank": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.pca_lowrank": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(q",
          "op": "is",
          "rhs": "None",
          "expr": "(q is None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(type(A)",
          "op": "is",
          "rhs": "not torch.Tensor && has_torch_function((A,))",
          "expr": "(type(A) is not torch.Tensor && has_torch_function((A,))",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "type(A)",
          "op": "is",
          "rhs": "not torch.Tensor && has_torch_function((A,))",
          "expr": "type(A) is not torch.Tensor && has_torch_function((A,))",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "q",
          "op": ">=",
          "rhs": "0 && q <= min(m, n)",
          "expr": "q >= 0 && q <= min(m, n)",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "_utils.is_sparse(A)",
          "op": "",
          "rhs": "",
          "expr": "_utils.is_sparse(A)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(not niter",
          "op": ">=",
          "rhs": "0",
          "expr": "(not niter >= 0",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "not center",
          "op": "",
          "rhs": "",
          "expr": "not center",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(len(A.shape)",
          "op": "!=",
          "rhs": "2",
          "expr": "(len(A.shape) != 2",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "q",
          "op": "is",
          "rhs": "None",
          "expr": "q is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(_utils.is_sparse(A)",
          "op": "",
          "rhs": "",
          "expr": "(_utils.is_sparse(A)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(not center",
          "op": "",
          "rhs": "",
          "expr": "(not center",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(q is None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(type(A) is not torch.Tensor && has_torch_function((A,))",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "type(A) is not torch.Tensor && has_torch_function((A,))",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "q >= 0 && q <= min(m, n)",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "_utils.is_sparse(A)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(not niter >= 0",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "not center",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(len(A.shape) != 2",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "q is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(_utils.is_sparse(A)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(not center",
        "src": "python",
        "type": "logical_check",
        "negated": true
      }
    ]
  },
  "torch.lobpcg": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not set(map(type, tensor_ops)).issubset((torch.Tensor, type(None))) && has_torch_function(tensor_ops)",
          "op": "",
          "rhs": "",
          "expr": "(not set(map(type, tensor_ops)).issubset((torch.Tensor, type(None))) && has_torch_function(tensor_ops)",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "not torch.jit.is_scripting()",
          "op": "",
          "rhs": "",
          "expr": "not torch.jit.is_scripting()",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not set(map(type, tensor_ops)).issubset((torch.Tensor, type(None))) && has_torch_function(tensor_ops)",
          "op": "",
          "rhs": "",
          "expr": "not set(map(type, tensor_ops)).issubset((torch.Tensor, type(None))) && has_torch_function(tensor_ops)",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "A.requires_grad || (B",
          "op": "is",
          "rhs": "not None && B.requires_grad)",
          "expr": "A.requires_grad || (B is not None && B.requires_grad)",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(not torch.jit.is_scripting()",
          "op": "",
          "rhs": "",
          "expr": "(not torch.jit.is_scripting()",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not torch._jit_internal.is_scripting()",
          "op": "",
          "rhs": "",
          "expr": "not torch._jit_internal.is_scripting()",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(A.requires_grad || (B",
          "op": "is",
          "rhs": "not None && B.requires_grad)",
          "expr": "(A.requires_grad || (B is not None && B.requires_grad)",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(not torch._jit_internal.is_scripting()",
          "op": "",
          "rhs": "",
          "expr": "(not torch._jit_internal.is_scripting()",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(not set(map(type, tensor_ops)).issubset((torch.Tensor, type(None))) && has_torch_function(tensor_ops)",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "not torch.jit.is_scripting()",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "not set(map(type, tensor_ops)).issubset((torch.Tensor, type(None))) && has_torch_function(tensor_ops)",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "A.requires_grad || (B is not None && B.requires_grad)",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(not torch.jit.is_scripting()",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "not torch._jit_internal.is_scripting()",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(A.requires_grad || (B is not None && B.requires_grad)",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(not torch._jit_internal.is_scripting()",
        "src": "python",
        "type": "logical_check",
        "negated": true
      }
    ]
  },
  "torch.trapz": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.triangular_solve": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.vdot": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self._is_zerotensor() || other._is_zerotensor()",
          "op": "",
          "rhs": "",
          "expr": "(self._is_zerotensor() || other._is_zerotensor()",
          "negated": true,
          "type": "logical_check",
          "src": "cpp"
        },
        {
          "lhs": "(other.is_conj()",
          "op": "",
          "rhs": "",
          "expr": "(other.is_conj()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "other.is_conj()",
          "op": "",
          "rhs": "",
          "expr": "other.is_conj()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "self._is_zerotensor() || other._is_zerotensor()",
          "op": "",
          "rhs": "",
          "expr": "self._is_zerotensor() || other._is_zerotensor()",
          "negated": false,
          "type": "logical_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self._is_zerotensor() || other._is_zerotensor()",
        "src": "cpp",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "(other.is_conj()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "other.is_conj()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "self._is_zerotensor() || other._is_zerotensor()",
        "src": "cpp",
        "type": "logical_check",
        "negated": false
      }
    ]
  },
  "torch.compiled_with_cxx11_abi": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.result_type": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.can_cast": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.promote_types": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.use_deterministic_algorithms": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.are_deterministic_algorithms_enabled": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch._assert": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "type(condition)",
          "op": "is",
          "rhs": "not torch.Tensor && overrides.has_torch_function((condition,))",
          "expr": "type(condition) is not torch.Tensor && overrides.has_torch_function((condition,))",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "condition",
          "op": "",
          "rhs": "",
          "expr": "condition",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(type(condition)",
          "op": "is",
          "rhs": "not torch.Tensor && overrides.has_torch_function((condition,))",
          "expr": "(type(condition) is not torch.Tensor && overrides.has_torch_function((condition,))",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "type(condition) is not torch.Tensor && overrides.has_torch_function((condition,))",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "condition",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(type(condition) is not torch.Tensor && overrides.has_torch_function((condition,))",
        "src": "python",
        "type": "logical_check",
        "negated": true
      }
    ]
  },
  "torch.nn.Sequential": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ModuleList": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ModuleDict": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ParameterList": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ParameterDict": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.modules.module.register_module_forward_pre_hook": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.modules.module.register_module_forward_hook": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "always_call",
          "op": "",
          "rhs": "",
          "expr": "always_call",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(always_call",
          "op": "",
          "rhs": "",
          "expr": "(always_call",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "always_call",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(always_call",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.modules.module.register_module_backward_hook": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(_global_is_full_backward_hook",
          "op": "is",
          "rhs": "True",
          "expr": "(_global_is_full_backward_hook is True",
          "negated": true,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(_global_is_full_backward_hook is True",
        "src": "python",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.Conv1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.Conv2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.Conv3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.ConvTranspose1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.ConvTranspose2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.ConvTranspose3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.LazyConv1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.LazyConv2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.LazyConv3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": false,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!bias.defined() || bias.dtype()",
          "op": "==",
          "rhs": "input_.dtype()",
          "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
          "negated": true,
          "type": "dtype_check",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!bias.defined() || bias.dtype() == input_.dtype()",
        "src": "cpp",
        "type": "dtype_check",
        "negated": true
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.LazyConvTranspose1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "at::isComplexType(input_.scalar_type())",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(at::isComplexType(input_.scalar_type())",
          "op": "",
          "rhs": "",
          "expr": "(at::isComplexType(input_.scalar_type())",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(at::isComplexType(input_.scalar_type())",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.LazyConvTranspose2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.LazyConvTranspose3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.padding_mode",
          "op": "!=",
          "rhs": "'zeros'",
          "expr": "self.padding_mode != 'zeros'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.padding_mode != 'zeros'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.Unfold": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Fold": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxPool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxPool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQInt8",
          "expr": "(self_arg.scalar_type() == kQInt8",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQUInt8",
          "expr": "self_arg.scalar_type() == kQUInt8",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQInt8",
          "expr": "self_arg.scalar_type() == kQInt8",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(self_arg.scalar_type()",
          "op": "==",
          "rhs": "kQUInt8",
          "expr": "(self_arg.scalar_type() == kQUInt8",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(self_arg.scalar_type() == kQInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self_arg.scalar_type() == kQUInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "self_arg.scalar_type() == kQInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(self_arg.scalar_type() == kQUInt8",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.MaxPool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.MaxUnpool1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.MaxUnpool2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.MaxUnpool3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.AvgPool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AvgPool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AvgPool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.FractionalMaxPool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.LPPool1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.LPPool2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "stride",
          "op": "is",
          "rhs": "not None",
          "expr": "stride is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "stride is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.AdaptiveMaxPool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveMaxPool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveMaxPool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveAvgPool1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.AdaptiveAvgPool2d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "2",
          "expr": "output_size.size() == 2",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size.size()",
          "op": "==",
          "rhs": "2",
          "expr": "(output_size.size() == 2",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0",
          "expr": "(output_size[0] >= 0 && output_size[1] >= 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(!input.is_quantized() && output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1",
          "expr": "(!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "!input.is_quantized() && output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1",
          "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "output_size.size() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(output_size.size() == 2",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(output_size[0] >= 0 && output_size[1] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "!input.is_quantized() && output_size[0] == 1 && output_size[1] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.AdaptiveAvgPool3d": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0 && output_size[2] >= 0",
          "expr": "(output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size.size()",
          "op": "==",
          "rhs": "3",
          "expr": "(output_size.size() == 3",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1 && output_size[2] == 1",
          "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size[0]",
          "op": ">=",
          "rhs": "0 && output_size[1] >= 0 && output_size[2] >= 0",
          "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "output_size.size()",
          "op": "==",
          "rhs": "3",
          "expr": "output_size.size() == 3",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(output_size[0]",
          "op": "==",
          "rhs": "1 && output_size[1] == 1 && output_size[2] == 1",
          "expr": "(output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(output_size.size() == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "output_size[0] >= 0 && output_size[1] >= 0 && output_size[2] >= 0",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "output_size.size() == 3",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(output_size[0] == 1 && output_size[1] == 1 && output_size[2] == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.ReflectionPad1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReflectionPad2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReplicationPad1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReplicationPad2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReplicationPad3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ZeroPad2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ConstantPad1d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ConstantPad2d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ConstantPad3d": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ELU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.Hardshrink": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Hardsigmoid": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.Hardtanh": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "min_val",
          "op": ">",
          "rhs": "max_val",
          "expr": "min_val > max_val",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "min_val > max_val",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.Hardswish": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.LeakyReLU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.MultiheadAttention": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.batch_first && is_batched",
          "op": "",
          "rhs": "",
          "expr": "self.batch_first && is_batched",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.add_zero_attn",
          "op": "",
          "rhs": "",
          "expr": "self.add_zero_attn",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "dropout_p",
          "op": ">",
          "rhs": "0.0",
          "expr": "dropout_p > 0.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "attn_mask.shape",
          "op": "!=",
          "rhs": "correct_2d_size",
          "expr": "attn_mask.shape != correct_2d_size",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "_mask_dtype",
          "op": "!=",
          "rhs": "other_type",
          "expr": "_mask_dtype != other_type",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.in_proj_bias",
          "op": "is",
          "rhs": "not None && query.dtype != self.in_proj_bias.dtype",
          "expr": "self.in_proj_bias is not None && query.dtype != self.in_proj_bias.dtype",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.in_proj_bias",
          "op": "is",
          "rhs": "not None && self.in_proj_weight is not None",
          "expr": "self.in_proj_bias is not None && self.in_proj_weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "bias_k",
          "op": "is",
          "rhs": "not None && bias_v is not None",
          "expr": "bias_k is not None && bias_v is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "add_zero_attn",
          "op": "",
          "rhs": "",
          "expr": "add_zero_attn",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.bias_k",
          "op": "is",
          "rhs": "not None",
          "expr": "self.bias_k is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "in_proj_bias",
          "op": "is",
          "rhs": "None",
          "expr": "in_proj_bias is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "_mask_dtype",
          "op": "!=",
          "rhs": "torch.bool && (not _mask_is_float)",
          "expr": "_mask_dtype != torch.bool && (not _mask_is_float)",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(embed_dim, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(embed_dim, torch.Tensor)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not self.batch_first",
          "op": "",
          "rhs": "",
          "expr": "not self.batch_first",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.bias_v",
          "op": "is",
          "rhs": "not None",
          "expr": "self.bias_v is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "attn_mask.shape",
          "op": "!=",
          "rhs": "correct_3d_size",
          "expr": "attn_mask.shape != correct_3d_size",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "query.dtype",
          "op": "!=",
          "rhs": "self.in_proj_weight.dtype",
          "expr": "query.dtype != self.in_proj_weight.dtype",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not self._qkv_same_embed_dim",
          "op": "",
          "rhs": "",
          "expr": "not self._qkv_same_embed_dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.num_heads % 2",
          "op": "!=",
          "rhs": "0",
          "expr": "self.num_heads % 2 != 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "not all((_check_arg_device(x) for x",
          "op": "in",
          "rhs": "tensor_args))",
          "expr": "not all((_check_arg_device(x) for x in tensor_args))",
          "negated": false,
          "type": "device_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "qkv_bias.sizes()[0]",
          "op": "==",
          "rhs": "3 * D",
          "expr": "qkv_bias.sizes()[0] == 3 * D",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(query.is_nested() || query.sizes()[2]",
          "op": "==",
          "rhs": "embed_dim",
          "expr": "(query.is_nested() || query.sizes()[2] == embed_dim",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(qkv_bias.sizes()[0]",
          "op": "==",
          "rhs": "3 * D",
          "expr": "(qkv_bias.sizes()[0] == 3 * D",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "query.is_nested() || query.sizes()[2]",
          "op": "==",
          "rhs": "embed_dim",
          "expr": "query.is_nested() || query.sizes()[2] == embed_dim",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "qkv_bias.dim()",
          "op": "==",
          "rhs": "1",
          "expr": "qkv_bias.dim() == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(qkv_bias.dim()",
          "op": "==",
          "rhs": "1",
          "expr": "(qkv_bias.dim() == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.batch_first && is_batched",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.add_zero_attn",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "dropout_p > 0.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "attn_mask.shape != correct_2d_size",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "_mask_dtype != other_type",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "self.in_proj_bias is not None && query.dtype != self.in_proj_bias.dtype",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "self.in_proj_bias is not None && self.in_proj_weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "bias_k is not None && bias_v is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "add_zero_attn",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "self.bias_k is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "in_proj_bias is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "_mask_dtype != torch.bool && (not _mask_is_float)",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "isinstance(embed_dim, torch.Tensor)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "not self.batch_first",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.bias_v is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "attn_mask.shape != correct_3d_size",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "query.dtype != self.in_proj_weight.dtype",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "not self._qkv_same_embed_dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.num_heads % 2 != 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "not all((_check_arg_device(x) for x in tensor_args))",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "qkv_bias.sizes()[0] == 3 * D",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(query.is_nested() || query.sizes()[2] == embed_dim",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "(qkv_bias.sizes()[0] == 3 * D",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "query.is_nested() || query.sizes()[2] == embed_dim",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "qkv_bias.dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(qkv_bias.dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      }
    ]
  },
  "torch.nn.PReLU": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.ReLU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(self.scalar_type()",
          "op": "!=",
          "rhs": "at::kBool",
          "expr": "(self.scalar_type() != at::kBool",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "self.scalar_type()",
          "op": "!=",
          "rhs": "at::kBool",
          "expr": "self.scalar_type() != at::kBool",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(self.scalar_type() != at::kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "self.scalar_type() != at::kBool",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.ReLU6": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.RReLU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.SELU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.CELU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "alpha.to",
          "op": "<",
          "rhs": "double>() != 0",
          "expr": "alpha.to<double>() != 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(alpha.to",
          "op": "<",
          "rhs": "double>() != 0",
          "expr": "(alpha.to<double>() != 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "alpha.to<double>() != 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(alpha.to<double>() != 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.SiLU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.Softplus": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Softshrink": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Threshold": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inplace",
          "op": "",
          "rhs": "",
          "expr": "inplace",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inplace",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.Softmin": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.nn.Softmax": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.nn.LogSoftmax": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.nn.AdaptiveLogSoftmaxWithLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "dtype",
          "op": "is",
          "rhs": "None",
          "expr": "dtype is None",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "dtype is None",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.nn.BatchNorm1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training && self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training && self.track_running_stats",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training && self.track_running_stats",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.BatchNorm2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training && self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training && self.track_running_stats",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training && self.track_running_stats",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.BatchNorm3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training && self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training && self.track_running_stats",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training && self.track_running_stats",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.GroupNorm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.SyncBatchNorm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.training && self.track_running_stats",
          "op": "",
          "rhs": "",
          "expr": "self.training && self.track_running_stats",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.process_group",
          "op": "",
          "rhs": "",
          "expr": "self.process_group",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "self.momentum",
          "op": "is",
          "rhs": "None",
          "expr": "self.momentum is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.device.type",
          "op": "not in",
          "rhs": "['cuda', torch._C._get_privateuse1_backend_name()]",
          "expr": "input.device.type not in ['cuda', torch._C._get_privateuse1_backend_name()]",
          "negated": false,
          "type": "device_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.training && self.track_running_stats",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.process_group",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "self.momentum is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "input.device.type not in ['cuda', torch._C._get_privateuse1_backend_name()]",
        "src": "python",
        "type": "device_check",
        "negated": false
      }
    ]
  },
  "torch.nn.InstanceNorm1d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.size(feature_dim)",
          "op": "!=",
          "rhs": "self.num_features",
          "expr": "input.size(feature_dim) != self.num_features",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.affine",
          "op": "",
          "rhs": "",
          "expr": "self.affine",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.size(feature_dim) != self.num_features",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.affine",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.InstanceNorm2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.size(feature_dim)",
          "op": "!=",
          "rhs": "self.num_features",
          "expr": "input.size(feature_dim) != self.num_features",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.affine",
          "op": "",
          "rhs": "",
          "expr": "self.affine",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.size(feature_dim) != self.num_features",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.affine",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.InstanceNorm3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.size(feature_dim)",
          "op": "!=",
          "rhs": "self.num_features",
          "expr": "input.size(feature_dim) != self.num_features",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.affine",
          "op": "",
          "rhs": "",
          "expr": "self.affine",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.size(feature_dim) != self.num_features",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.affine",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.LayerNorm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.LocalResponseNorm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.RNNBase": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.RNN": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.input_size",
          "op": "!=",
          "rhs": "input.size(-1)",
          "expr": "self.input_size != input.size(-1)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "hx.size()",
          "op": "!=",
          "rhs": "expected_hidden_size",
          "expr": "hx.size() != expected_hidden_size",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dtype",
          "op": "!=",
          "rhs": "self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
          "expr": "input.dtype != self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(fw, Tensor) || not fw.dtype",
          "op": "==",
          "rhs": "dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
          "expr": "not isinstance(fw, Tensor) || not fw.dtype == dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.input_size != input.size(-1)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "hx.size() != expected_hidden_size",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dtype != self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "not isinstance(fw, Tensor) || not fw.dtype == dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.nn.LSTM": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.input_size",
          "op": "!=",
          "rhs": "input.size(-1)",
          "expr": "self.input_size != input.size(-1)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "hx.size()",
          "op": "!=",
          "rhs": "expected_hidden_size",
          "expr": "hx.size() != expected_hidden_size",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dtype",
          "op": "!=",
          "rhs": "self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
          "expr": "input.dtype != self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(fw, Tensor) || not fw.dtype",
          "op": "==",
          "rhs": "dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
          "expr": "not isinstance(fw, Tensor) || not fw.dtype == dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.proj_size",
          "op": ">",
          "rhs": "0",
          "expr": "self.proj_size > 0",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.input_size != input.size(-1)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "hx.size() != expected_hidden_size",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dtype != self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "not isinstance(fw, Tensor) || not fw.dtype == dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "self.proj_size > 0",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.GRU": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.input_size",
          "op": "!=",
          "rhs": "input.size(-1)",
          "expr": "self.input_size != input.size(-1)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "hx.size()",
          "op": "!=",
          "rhs": "expected_hidden_size",
          "expr": "hx.size() != expected_hidden_size",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dtype",
          "op": "!=",
          "rhs": "self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
          "expr": "input.dtype != self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(fw, Tensor) || not fw.dtype",
          "op": "==",
          "rhs": "dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
          "expr": "not isinstance(fw, Tensor) || not fw.dtype == dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.input_size != input.size(-1)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "hx.size() != expected_hidden_size",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dtype != self._flat_weights[0].dtype && (not torch._C._is_any_autocast_enabled())",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "not isinstance(fw, Tensor) || not fw.dtype == dtype || (not fw.is_cuda) || (not torch.backends.cudnn.is_acceptable(fw))",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      }
    ]
  },
  "torch.nn.RNNCell": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.nonlinearity",
          "op": "==",
          "rhs": "'tanh'",
          "expr": "self.nonlinearity == 'tanh'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "self.nonlinearity",
          "op": "==",
          "rhs": "'relu'",
          "expr": "self.nonlinearity == 'relu'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.nonlinearity == 'tanh'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "self.nonlinearity == 'relu'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.LSTMCell": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.GRUCell": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Transformer": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "not self.batch_first && src.size(1)",
          "op": "!=",
          "rhs": "tgt.size(1) && is_batched",
          "expr": "not self.batch_first && src.size(1) != tgt.size(1) && is_batched",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "self.batch_first && src.size(0)",
          "op": "!=",
          "rhs": "tgt.size(0) && is_batched",
          "expr": "self.batch_first && src.size(0) != tgt.size(0) && is_batched",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "src.size(-1)",
          "op": "!=",
          "rhs": "self.d_model || tgt.size(-1) != self.d_model",
          "expr": "src.size(-1) != self.d_model || tgt.size(-1) != self.d_model",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not self.batch_first && src.size(1) != tgt.size(1) && is_batched",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "self.batch_first && src.size(0) != tgt.size(0) && is_batched",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "src.size(-1) != self.d_model || tgt.size(-1) != self.d_model",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.TransformerEncoder": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "_mask_dtype",
          "op": "!=",
          "rhs": "other_type",
          "expr": "_mask_dtype != other_type",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "src.device.type",
          "op": "not in",
          "rhs": "_supported_device_type",
          "expr": "src.device.type not in _supported_device_type",
          "negated": false,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "_mask_dtype",
          "op": "!=",
          "rhs": "torch.bool && (not _mask_is_float)",
          "expr": "_mask_dtype != torch.bool && (not _mask_is_float)",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.norm",
          "op": "is",
          "rhs": "not None",
          "expr": "self.norm is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "mask.scalar_type()",
          "op": "==",
          "rhs": "at::ScalarType::Bool",
          "expr": "mask.scalar_type() == at::ScalarType::Bool",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(mask.scalar_type()",
          "op": "==",
          "rhs": "at::ScalarType::Bool",
          "expr": "(mask.scalar_type() == at::ScalarType::Bool",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "_mask_dtype != other_type",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "src.device.type not in _supported_device_type",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "_mask_dtype != torch.bool && (not _mask_is_float)",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "self.norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "mask.scalar_type() == at::ScalarType::Bool",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(mask.scalar_type() == at::ScalarType::Bool",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.TransformerDecoder": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.norm",
          "op": "is",
          "rhs": "not None",
          "expr": "self.norm is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.TransformerEncoderLayer": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.self_attn.in_proj_bias",
          "op": "is",
          "rhs": "None",
          "expr": "self.self_attn.in_proj_bias is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "not all((x.device.type",
          "op": "in",
          "rhs": "_supported_device_type for x in tensor_args))",
          "expr": "not all((x.device.type in _supported_device_type for x in tensor_args))",
          "negated": false,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "_mask_dtype",
          "op": "!=",
          "rhs": "other_type",
          "expr": "_mask_dtype != other_type",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "self.norm_first",
          "op": "",
          "rhs": "",
          "expr": "self.norm_first",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "_mask_dtype",
          "op": "!=",
          "rhs": "torch.bool && (not _mask_is_float)",
          "expr": "_mask_dtype != torch.bool && (not _mask_is_float)",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "not self.self_attn.batch_first",
          "op": "",
          "rhs": "",
          "expr": "not self.self_attn.batch_first",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not self.activation_relu_or_gelu",
          "op": "",
          "rhs": "",
          "expr": "not self.activation_relu_or_gelu",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(norm_first",
          "op": "",
          "rhs": "",
          "expr": "(norm_first",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "!norm_first",
          "op": "",
          "rhs": "",
          "expr": "!norm_first",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "norm_first",
          "op": "",
          "rhs": "",
          "expr": "norm_first",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(!norm_first",
          "op": "",
          "rhs": "",
          "expr": "(!norm_first",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "self.self_attn.in_proj_bias is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "not all((x.device.type in _supported_device_type for x in tensor_args))",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "_mask_dtype != other_type",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "self.norm_first",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "_mask_dtype != torch.bool && (not _mask_is_float)",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "not self.self_attn.batch_first",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "not self.activation_relu_or_gelu",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "(norm_first",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "!norm_first",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "norm_first",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(!norm_first",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      }
    ]
  },
  "torch.nn.TransformerDecoderLayer": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.norm_first",
          "op": "",
          "rhs": "",
          "expr": "self.norm_first",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.norm_first",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.Identity": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Linear": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "(bias->defined() && !input.is_xla()",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "bias->defined()",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "(input_dim == 2 && bias->defined()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "input_dim == 2 && bias->defined()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "(input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "bias->defined() && !input.is_xla()",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "(bias->defined()",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "bias->defined()",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(bias->defined()",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.Bilinear": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.LazyLinear": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "(bias->defined() && !input.is_xla()",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "bias->defined()",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "(input_dim == 2 && bias->defined()",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input_dim",
          "op": "==",
          "rhs": "2 && bias->defined()",
          "expr": "input_dim == 2 && bias->defined()",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "(input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "(input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "negated": true,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "input.is_contiguous() && input.layout()",
          "op": "==",
          "rhs": "c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
          "negated": false,
          "type": "shape_check",
          "src": "cpp"
        },
        {
          "lhs": "bias-",
          "op": ">",
          "rhs": "defined() && !input.is_xla()",
          "expr": "bias->defined() && !input.is_xla()",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(bias-",
          "op": ">",
          "rhs": "defined()",
          "expr": "(bias->defined()",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "bias->defined()",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input_dim == 2 && bias->defined()",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "input.is_contiguous() && input.layout() == c10::kStrided && weight.layout() == c10::kStrided && bias->dim() == 1",
        "src": "cpp",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "bias->defined() && !input.is_xla()",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(bias->defined()",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.Dropout": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "p < 0.0 || p > 1.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.Dropout2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inp_dim",
          "op": "not in",
          "rhs": "(3, 4)",
          "expr": "inp_dim not in (3, 4)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "inp_dim",
          "op": "==",
          "rhs": "3",
          "expr": "inp_dim == 3",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "p < 0.0 || p > 1.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inp_dim not in (3, 4)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "inp_dim == 3",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.Dropout3d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "inp_dim",
          "op": "not in",
          "rhs": "(4, 5)",
          "expr": "inp_dim not in (4, 5)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "p < 0.0 || p > 1.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "inp_dim not in (4, 5)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.AlphaDropout": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_unary(input)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_unary(input)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "p",
          "op": "<",
          "rhs": "0.0 || p > 1.0",
          "expr": "p < 0.0 || p > 1.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_unary(input)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "p < 0.0 || p > 1.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.Embedding": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "padding_idx",
          "op": "is",
          "rhs": "not None",
          "expr": "padding_idx is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": ">",
          "rhs": "0",
          "expr": "padding_idx > 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "padding_idx",
          "op": "<",
          "rhs": "0",
          "expr": "padding_idx < 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "padding_idx is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "padding_idx > 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "padding_idx < 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.EmbeddingBag": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'max'",
          "expr": "mode == 'max'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "scale_grad_by_freq",
          "op": "",
          "rhs": "",
          "expr": "scale_grad_by_freq",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "sparse",
          "op": "",
          "rhs": "",
          "expr": "sparse",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight.dtype",
          "op": "==",
          "rhs": "torch.long && input.is_floating_point()",
          "expr": "weight.dtype == torch.long && input.is_floating_point()",
          "negated": false,
          "type": "dtype_check",
          "src": "python"
        },
        {
          "lhs": "per_sample_weights",
          "op": "is",
          "rhs": "not None && mode != 'sum'",
          "expr": "per_sample_weights is not None && mode != 'sum'",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "max_norm",
          "op": "is",
          "rhs": "not None",
          "expr": "max_norm is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'mean'",
          "expr": "mode == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'sum'",
          "expr": "mode == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "mode == 'max'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "scale_grad_by_freq",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "sparse",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "weight.dtype == torch.long && input.is_floating_point()",
        "src": "python",
        "type": "dtype_check",
        "negated": false
      },
      {
        "expr": "per_sample_weights is not None && mode != 'sum'",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "max_norm is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "mode == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "mode == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.CosineSimilarity": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.PairwiseDistance": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.L1Loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.MSELoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "(reduction == Reduction::Mean",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "(reduction != Reduction::None",
          "negated": true,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "negated": false,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.CrossEntropyLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.NLLLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.CTCLoss": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.PoissonNLLLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "'none' && reduction != 'mean' && (reduction != 'sum')",
          "expr": "reduction != 'none' && reduction != 'mean' && (reduction != 'sum')",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "reduction != 'none' && reduction != 'mean' && (reduction != 'sum')",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.GaussianNLLLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "'none' && reduction != 'mean' && (reduction != 'sum')",
          "expr": "reduction != 'none' && reduction != 'mean' && (reduction != 'sum')",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "full",
          "op": "",
          "rhs": "",
          "expr": "full",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction != 'none' && reduction != 'mean' && (reduction != 'sum')",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "full",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.KLDivLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean' && input.dim() != 0",
          "expr": "reduction == 'batchmean' && input.dim() != 0",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'batchmean'",
          "expr": "reduction == 'batchmean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "reduction == 'batchmean' && input.dim() != 0",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "reduction == 'batchmean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.BCELoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.BCEWithLogitsLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(pos_weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "(pos_weight.defined()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "weight.defined()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "(weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "(weight.defined()",
          "negated": true,
          "type": "boolean",
          "src": "cpp"
        },
        {
          "lhs": "pos_weight.defined()",
          "op": "",
          "rhs": "",
          "expr": "pos_weight.defined()",
          "negated": false,
          "type": "boolean",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight, pos_weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(pos_weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "pos_weight.defined()",
        "src": "cpp",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.MarginRankingLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.HingeEmbeddingLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.MultiLabelMarginLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.SmoothL1Loss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "beta",
          "op": "==",
          "rhs": "0.0",
          "expr": "beta == 0.0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": [
        {
          "lhs": "(reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "(reduction == Reduction::Mean",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "(reduction != Reduction::None",
          "negated": true,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "!=",
          "rhs": "Reduction::None",
          "expr": "reduction != Reduction::None",
          "negated": false,
          "type": "existence_check",
          "src": "cpp"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "Reduction::Mean",
          "expr": "reduction == Reduction::Mean",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "beta == 0.0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "(reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "reduction != Reduction::None",
        "src": "cpp",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "reduction == Reduction::Mean",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.SoftMarginLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.MultiLabelSoftMarginLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'none'",
          "expr": "reduction == 'none'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "reduction == 'none'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.CosineEmbeddingLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.MultiMarginLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "p",
          "op": "!=",
          "rhs": "1 && p != 2",
          "expr": "p != 1 && p != 2",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "weight",
          "op": "is",
          "rhs": "not None",
          "expr": "weight is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "has_torch_function_variadic(input, target, weight)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(input, target, weight)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "weight.dim()",
          "op": "!=",
          "rhs": "1",
          "expr": "weight.dim() != 1",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "p != 1 && p != 2",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "weight is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "has_torch_function_variadic(input, target, weight)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "weight.dim() != 1",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.TripletMarginLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "has_torch_function_variadic(anchor, positive, negative)",
          "op": "",
          "rhs": "",
          "expr": "has_torch_function_variadic(anchor, positive, negative)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "margin",
          "op": "<=",
          "rhs": "0",
          "expr": "margin <= 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "size_average",
          "op": "is",
          "rhs": "not None || reduce is not None",
          "expr": "size_average is not None || reduce is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "has_torch_function_variadic(anchor, positive, negative)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "margin <= 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "size_average is not None || reduce is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.TripletMarginWithDistanceLoss": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "reduction",
          "op": "not in",
          "rhs": "('mean', 'sum', 'none')",
          "expr": "reduction not in ('mean', 'sum', 'none')",
          "negated": false,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'mean'",
          "expr": "reduction == 'mean'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "swap",
          "op": "",
          "rhs": "",
          "expr": "swap",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "reduction",
          "op": "==",
          "rhs": "'sum'",
          "expr": "reduction == 'sum'",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "margin",
          "op": "<=",
          "rhs": "0",
          "expr": "margin <= 0",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "distance_function",
          "op": "is",
          "rhs": "None",
          "expr": "distance_function is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "reduction not in ('mean', 'sum', 'none')",
        "src": "python",
        "type": "membership_check",
        "negated": false
      },
      {
        "expr": "reduction == 'mean'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "swap",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "reduction == 'sum'",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "margin <= 0",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "distance_function is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      }
    ]
  },
  "torch.nn.PixelShuffle": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.PixelUnshuffle": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Upsample": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'nearest'",
          "expr": "input.dim() == 5 && mode == 'nearest'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'trilinear'",
          "expr": "input.dim() == 3 && mode == 'trilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'bilinear'",
          "expr": "input.dim() == 4 && mode == 'bilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'bilinear'",
          "expr": "input.dim() == 3 && mode == 'bilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "not None",
          "expr": "align_corners is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "in",
          "rhs": "('nearest', 'area', 'nearest-exact')",
          "expr": "mode in ('nearest', 'area', 'nearest-exact')",
          "negated": false,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'nearest-exact'",
          "expr": "input.dim() == 3 && mode == 'nearest-exact'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'nearest'",
          "expr": "input.dim() == 3 && mode == 'nearest'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'area' && output_size is None",
          "expr": "mode == 'area' && output_size is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'area'",
          "expr": "input.dim() == 3 && mode == 'area'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'nearest-exact'",
          "expr": "input.dim() == 4 && mode == 'nearest-exact'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'area'",
          "expr": "input.dim() == 5 && mode == 'area'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "align_corners",
          "op": "is",
          "rhs": "None",
          "expr": "align_corners is None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'bicubic'",
          "expr": "input.dim() == 4 && mode == 'bicubic'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "antialias && (not (mode",
          "op": "in",
          "rhs": "('bilinear', 'bicubic') && input.ndim == 4))",
          "expr": "antialias && (not (mode in ('bilinear', 'bicubic') && input.ndim == 4))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'linear'",
          "expr": "input.dim() == 4 && mode == 'linear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'bilinear'",
          "expr": "input.dim() == 5 && mode == 'bilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "3 && mode == 'linear'",
          "expr": "input.dim() == 3 && mode == 'linear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor && (size is not None)",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'trilinear'",
          "expr": "input.dim() == 5 && mode == 'trilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'linear'",
          "expr": "input.dim() == 5 && mode == 'linear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "5 && mode == 'nearest-exact'",
          "expr": "input.dim() == 5 && mode == 'nearest-exact'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'area'",
          "expr": "input.dim() == 4 && mode == 'area'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'nearest'",
          "expr": "input.dim() == 4 && mode == 'nearest'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None && scale_factor is not None",
          "expr": "size is not None && scale_factor is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "input.dim()",
          "op": "==",
          "rhs": "4 && mode == 'trilinear'",
          "expr": "input.dim() == 4 && mode == 'trilinear'",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "input.dim() == 5 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "align_corners is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "mode in ('nearest', 'area', 'nearest-exact')",
        "src": "python",
        "type": "membership_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "mode == 'area' && output_size is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "align_corners is None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'bicubic'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "antialias && (not (mode in ('bilinear', 'bicubic') && input.ndim == 4))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'bilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 3 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'linear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 5 && mode == 'nearest-exact'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'area'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'nearest'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "size is not None && scale_factor is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "input.dim() == 4 && mode == 'trilinear'",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.UpsamplingNearest2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'area' && output_size is None",
          "expr": "mode == 'area' && output_size is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor && (size is not None)",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None && scale_factor is not None",
          "expr": "size is not None && scale_factor is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "mode == 'area' && output_size is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "size is not None && scale_factor is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.UpsamplingBilinear2d": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None",
          "expr": "size is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "mode",
          "op": "==",
          "rhs": "'area' && output_size is None",
          "expr": "mode == 'area' && output_size is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(size)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(size) != dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(size, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(size, (list, tuple))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(scale_factor, (list, tuple))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(scale_factor, (list, tuple))",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "recompute_scale_factor",
          "op": "is",
          "rhs": "not None && recompute_scale_factor && (size is not None)",
          "expr": "recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "len(scale_factor)",
          "op": "!=",
          "rhs": "dim",
          "expr": "len(scale_factor) != dim",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "not all((_is_integer(x) for x",
          "op": "in",
          "rhs": "size))",
          "expr": "not all((_is_integer(x) for x in size))",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "scale_factor",
          "op": "is",
          "rhs": "not None",
          "expr": "scale_factor is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "size",
          "op": "is",
          "rhs": "not None && scale_factor is not None",
          "expr": "size is not None && scale_factor is not None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "size is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "mode == 'area' && output_size is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(size) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "isinstance(size, (list, tuple))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "isinstance(scale_factor, (list, tuple))",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "recompute_scale_factor is not None && recompute_scale_factor && (size is not None)",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "len(scale_factor) != dim",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "not all((_is_integer(x) for x in size))",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "scale_factor is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "size is not None && scale_factor is not None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      }
    ]
  },
  "torch.nn.ChannelShuffle": {
    "normalized_guards": {
      "python": [],
      "cpp": [
        {
          "lhs": "(groups",
          "op": ">",
          "rhs": "0",
          "expr": "(groups > 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "groups",
          "op": ">",
          "rhs": "0",
          "expr": "groups > 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "(c % groups)",
          "op": "==",
          "rhs": "0",
          "expr": "(c % groups) == 0",
          "negated": false,
          "type": "value_check",
          "src": "cpp"
        },
        {
          "lhs": "((c % groups)",
          "op": "==",
          "rhs": "0",
          "expr": "((c % groups) == 0",
          "negated": true,
          "type": "value_check",
          "src": "cpp"
        }
      ]
    },
    "for_path_enumeration": [
      {
        "expr": "(groups > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "groups > 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(c % groups) == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "((c % groups) == 0",
        "src": "cpp",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.DataParallel": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "not self.device_ids",
          "op": "",
          "rhs": "",
          "expr": "not self.device_ids",
          "negated": false,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "not inputs && (not module_kwargs)",
          "op": "",
          "rhs": "",
          "expr": "not inputs && (not module_kwargs)",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "len(self.device_ids)",
          "op": "==",
          "rhs": "1",
          "expr": "len(self.device_ids) == 1",
          "negated": false,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "t.device",
          "op": "!=",
          "rhs": "self.src_device_obj",
          "expr": "t.device != self.src_device_obj",
          "negated": false,
          "type": "device_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "not self.device_ids",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "not inputs && (not module_kwargs)",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "len(self.device_ids) == 1",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "t.device != self.src_device_obj",
        "src": "python",
        "type": "device_check",
        "negated": false
      }
    ]
  },
  "torch.nn.parallel.DistributedDataParallel": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "self.find_unused_parameters && (not self.static_graph) || (self.static_graph && (not self._static_graph_delay_allreduce_enqueued))",
          "op": "",
          "rhs": "",
          "expr": "self.find_unused_parameters && (not self.static_graph) || (self.static_graph && (not self._static_graph_delay_allreduce_enqueued))",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "self.device_ids",
          "op": "",
          "rhs": "",
          "expr": "self.device_ids",
          "negated": false,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "any((hasattr(p, '_in_backward_optimizers') for p",
          "op": "in",
          "rhs": "self._module_parameters))",
          "expr": "any((hasattr(p, '_in_backward_optimizers') for p in self._module_parameters))",
          "negated": false,
          "type": "membership_check",
          "src": "python"
        },
        {
          "lhs": "self.find_unused_parameters && (not self.static_graph)",
          "op": "",
          "rhs": "",
          "expr": "self.find_unused_parameters && (not self.static_graph)",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "self.find_unused_parameters && (not self.static_graph) || (self.static_graph && (not self._static_graph_delay_allreduce_enqueued))",
        "src": "python",
        "type": "logical_check",
        "negated": false
      },
      {
        "expr": "self.device_ids",
        "src": "python",
        "type": "device_check",
        "negated": false
      },
      {
        "expr": "any((hasattr(p, '_in_backward_optimizers') for p in self._module_parameters))",
        "src": "python",
        "type": "membership_check",
        "negated": false
      },
      {
        "expr": "self.find_unused_parameters && (not self.static_graph)",
        "src": "python",
        "type": "logical_check",
        "negated": false
      }
    ]
  },
  "torch.nn.utils.clip_grad_norm_": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "isinstance(parameters, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(parameters, torch.Tensor)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(foreach",
          "op": "is",
          "rhs": "None && _has_foreach_support(device_grads, device) || (foreach && _device_has_foreach_support(device))",
          "expr": "(foreach is None && _has_foreach_support(device_grads, device) || (foreach && _device_has_foreach_support(device))",
          "negated": true,
          "type": "device_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(parameters, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(parameters, torch.Tensor)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(error_if_nonfinite && torch.logical_or(total_norm.isnan(), total_norm.isinf())",
          "op": "",
          "rhs": "",
          "expr": "(error_if_nonfinite && torch.logical_or(total_norm.isnan(), total_norm.isinf())",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "(foreach",
          "op": "",
          "rhs": "",
          "expr": "(foreach",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "foreach",
          "op": "is",
          "rhs": "None && _has_foreach_support(device_grads, device) || (foreach && _device_has_foreach_support(device))",
          "expr": "foreach is None && _has_foreach_support(device_grads, device) || (foreach && _device_has_foreach_support(device))",
          "negated": false,
          "type": "device_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "isinstance(parameters, torch.Tensor)",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(foreach is None && _has_foreach_support(device_grads, device) || (foreach && _device_has_foreach_support(device))",
        "src": "python",
        "type": "device_check",
        "negated": true
      },
      {
        "expr": "(isinstance(parameters, torch.Tensor)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(error_if_nonfinite && torch.logical_or(total_norm.isnan(), total_norm.isinf())",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "(foreach",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "foreach is None && _has_foreach_support(device_grads, device) || (foreach && _device_has_foreach_support(device))",
        "src": "python",
        "type": "device_check",
        "negated": false
      }
    ]
  },
  "torch.nn.utils.parameters_to_vector": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.utils.vector_to_parameters": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(not isinstance(vec, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "(not isinstance(vec, torch.Tensor)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(not isinstance(vec, torch.Tensor)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      }
    ]
  },
  "torch.nn.utils.weight_norm": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.utils.remove_weight_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(isinstance(hook, WeightNorm) && hook.name",
          "op": "==",
          "rhs": "name",
          "expr": "(isinstance(hook, WeightNorm) && hook.name == name",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(hook, WeightNorm) && hook.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, WeightNorm) && hook.name == name",
          "negated": false,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(isinstance(hook, WeightNorm) && hook.name == name",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "isinstance(hook, WeightNorm) && hook.name == name",
        "src": "python",
        "type": "value_check",
        "negated": false
      }
    ]
  },
  "torch.nn.utils.spectral_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(dim",
          "op": "is",
          "rhs": "None",
          "expr": "(dim is None",
          "negated": true,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "dim",
          "op": "is",
          "rhs": "None",
          "expr": "dim is None",
          "negated": false,
          "type": "shape_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
          "op": "",
          "rhs": "",
          "expr": "isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": true
      },
      {
        "expr": "dim is None",
        "src": "python",
        "type": "shape_check",
        "negated": false
      },
      {
        "expr": "(isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "isinstance(module, (torch.nn.ConvTranspose1d, torch.nn.ConvTranspose2d, torch.nn.ConvTranspose3d))",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.utils.remove_spectral_norm": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(isinstance(hook, SpectralNormStateDictHook) && hook.fn.name",
          "op": "==",
          "rhs": "name",
          "expr": "(isinstance(hook, SpectralNormStateDictHook) && hook.fn.name == name",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(hook, SpectralNormLoadStateDictPreHook) && hook.fn.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, SpectralNormLoadStateDictPreHook) && hook.fn.name == name",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(hook, SpectralNormStateDictHook) && hook.fn.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, SpectralNormStateDictHook) && hook.fn.name == name",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(hook, SpectralNormLoadStateDictPreHook) && hook.fn.name",
          "op": "==",
          "rhs": "name",
          "expr": "(isinstance(hook, SpectralNormLoadStateDictPreHook) && hook.fn.name == name",
          "negated": true,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(hook, SpectralNorm) && hook.name",
          "op": "==",
          "rhs": "name",
          "expr": "isinstance(hook, SpectralNorm) && hook.name == name",
          "negated": false,
          "type": "value_check",
          "src": "python"
        },
        {
          "lhs": "(isinstance(hook, SpectralNorm) && hook.name",
          "op": "==",
          "rhs": "name",
          "expr": "(isinstance(hook, SpectralNorm) && hook.name == name",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(isinstance(hook, SpectralNormStateDictHook) && hook.fn.name == name",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "isinstance(hook, SpectralNormLoadStateDictPreHook) && hook.fn.name == name",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "isinstance(hook, SpectralNormStateDictHook) && hook.fn.name == name",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(isinstance(hook, SpectralNormLoadStateDictPreHook) && hook.fn.name == name",
        "src": "python",
        "type": "value_check",
        "negated": true
      },
      {
        "expr": "isinstance(hook, SpectralNorm) && hook.name == name",
        "src": "python",
        "type": "value_check",
        "negated": false
      },
      {
        "expr": "(isinstance(hook, SpectralNorm) && hook.name == name",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.utils.rnn.pack_padded_sequence": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "enforce_sorted",
          "op": "",
          "rhs": "",
          "expr": "enforce_sorted",
          "negated": false,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(enforce_sorted",
          "op": "",
          "rhs": "",
          "expr": "(enforce_sorted",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(not isinstance(lengths, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "(not isinstance(lengths, torch.Tensor)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "not isinstance(lengths, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "not isinstance(lengths, torch.Tensor)",
          "negated": false,
          "type": "logical_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "enforce_sorted",
        "src": "python",
        "type": "boolean",
        "negated": false
      },
      {
        "expr": "(enforce_sorted",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(not isinstance(lengths, torch.Tensor)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "not isinstance(lengths, torch.Tensor)",
        "src": "python",
        "type": "logical_check",
        "negated": false
      }
    ]
  },
  "torch.nn.utils.rnn.pad_packed_sequence": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "total_length",
          "op": "is",
          "rhs": "not None",
          "expr": "total_length is not None",
          "negated": false,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(total_length",
          "op": "is",
          "rhs": "not None",
          "expr": "(total_length is not None",
          "negated": true,
          "type": "existence_check",
          "src": "python"
        },
        {
          "lhs": "(total_length",
          "op": "<",
          "rhs": "max_seq_length",
          "expr": "(total_length < max_seq_length",
          "negated": true,
          "type": "value_check",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "total_length is not None",
        "src": "python",
        "type": "existence_check",
        "negated": false
      },
      {
        "expr": "(total_length is not None",
        "src": "python",
        "type": "existence_check",
        "negated": true
      },
      {
        "expr": "(total_length < max_seq_length",
        "src": "python",
        "type": "value_check",
        "negated": true
      }
    ]
  },
  "torch.nn.utils.rnn.pad_sequence": {
    "normalized_guards": {
      "python": [
        {
          "lhs": "(isinstance(sequences, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "(isinstance(sequences, torch.Tensor)",
          "negated": true,
          "type": "boolean",
          "src": "python"
        },
        {
          "lhs": "(not isinstance(sequences, Iterable)",
          "op": "",
          "rhs": "",
          "expr": "(not isinstance(sequences, Iterable)",
          "negated": true,
          "type": "logical_check",
          "src": "python"
        },
        {
          "lhs": "isinstance(sequences, torch.Tensor)",
          "op": "",
          "rhs": "",
          "expr": "isinstance(sequences, torch.Tensor)",
          "negated": false,
          "type": "boolean",
          "src": "python"
        }
      ],
      "cpp": []
    },
    "for_path_enumeration": [
      {
        "expr": "(isinstance(sequences, torch.Tensor)",
        "src": "python",
        "type": "boolean",
        "negated": true
      },
      {
        "expr": "(not isinstance(sequences, Iterable)",
        "src": "python",
        "type": "logical_check",
        "negated": true
      },
      {
        "expr": "isinstance(sequences, torch.Tensor)",
        "src": "python",
        "type": "boolean",
        "negated": false
      }
    ]
  },
  "torch.nn.utils.rnn.pack_sequence": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Flatten": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.Unflatten": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  },
  "torch.nn.modules.lazy.LazyModuleMixin": {
    "normalized_guards": {
      "python": [],
      "cpp": []
    },
    "for_path_enumeration": []
  }
}